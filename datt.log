"/Users/aswin/Documents/quivr/backend/routes/chat_routes.py" ```import os
import time
from typing import Optional
from uuid import UUID

from auth.auth_bearer import JWTBearer
from fastapi import APIRouter, Depends, Request
from models.chats import ChatMessage
from models.users import User
from utils.vectors import (CommonsDep, create_chat, create_user,
                           fetch_user_id_from_credentials, get_answer,
                           get_chat_name_from_first_question, update_chat,
                           update_user_request_count)

chat_router = APIRouter()
@chat_router.get("/chat", dependencies=[Depends(JWTBearer())])
async def get_chats(commons: CommonsDep, credentials: dict = Depends(JWTBearer())):
    date = time.strftime("%Y%m%d")
    user_id = fetch_user_id_from_credentials(commons,date, credentials)
    response = commons['supabase'].from_('chats').select('chatId:chat_id, chatName:chat_name').filter("user_id", "eq", user_id).execute()
    chats = response.data
    return {"chats": chats}
@chat_router.get("/chat/{chat_id}", dependencies=[Depends(JWTBearer())])
async def get_chats(commons: CommonsDep, chat_id: UUID):
    response = commons['supabase'].from_('chats').select('*').filter("chat_id", "eq", chat_id).execute()
    chats = response.data

    print("/chat/{chat_id}",chats)
    return {"chatId": chat_id, "history": chats[0]['history']}
@chat_router.delete("/chat/{chat_id}", dependencies=[Depends(JWTBearer())])
async def delete_chat(commons: CommonsDep,chat_id: UUID):
    commons['supabase'].table("chats").delete().match(
        {"chat_id": chat_id}).execute()

    return {"message": f"{chat_id}  has been deleted."}
@chat_router.put("/chat/{chat_id}", dependencies=[Depends(JWTBearer())])
async def chat_endpoint(request: Request,commons: CommonsDep,  chat_id: UUID, chat_message: ChatMessage, credentials: dict = Depends(JWTBearer())):
    user = User(email=credentials.get('email', 'none'))
    date = time.strftime("%Y%m%d")
    max_requests_number = os.getenv("MAX_REQUESTS_NUMBER")
    user_openai_api_key = request.headers.get('Openai-Api-Key')

    response = commons['supabase'].from_('users').select(
    '*').filter("email", "eq", user.email).filter("date", "eq", date).execute()


    userItem = next(iter(response.data or []), {"requests_count": 0})
    old_request_count = userItem['requests_count']

    history = chat_message.history
    history.append(("user", chat_message.question))

    if old_request_count == 0: 
        create_user(email= user.email, date=date)
    elif  old_request_count <  float(max_requests_number) : 
        update_user_request_count(email=user.email,  date=date, requests_count= old_request_count+1)
    else: 
        history.append(('assistant', "You have reached your requests limit"))
        update_chat(chat_id=chat_id, history=history)
        return {"history": history }

    answer = get_answer(commons, chat_message, user.email,user_openai_api_key)
    history.append(("assistant", answer))
    update_chat(chat_id=chat_id, history=history)
    
    return {"history": history, "chatId": chat_id}
@chat_router.post("/chat", dependencies=[Depends(JWTBearer())])
async def chat_endpoint(request: Request,commons: CommonsDep,  chat_message: ChatMessage, credentials: dict = Depends(JWTBearer())):
    user = User(email=credentials.get('email', 'none'))
    date = time.strftime("%Y%m%d")

    user_id = fetch_user_id_from_credentials(commons, date,credentials)

    max_requests_number = os.getenv("MAX_REQUESTS_NUMBER")
    user_openai_api_key = request.headers.get('Openai-Api-Key')

    response = commons['supabase'].from_('users').select(
    '*').filter("email", "eq", user.email).filter("date", "eq", date).execute()


    userItem = next(iter(response.data or []), {"requests_count": 0})
    old_request_count = userItem['requests_count']

    history = chat_message.history
    history.append(("user", chat_message.question))

    chat_name = get_chat_name_from_first_question(chat_message)
    print('chat_name',chat_name)  
    if user_openai_api_key is None:
        if old_request_count == 0: 
            create_user(email= user.email, date=date)
        elif  old_request_count <  float(max_requests_number) : 
            update_user_request_count(email=user.email,  date=date, requests_count= old_request_count+1)
        else: 
            history.append(('assistant', "You have reached your requests limit"))
            new_chat = create_chat(user_id, history, chat_name) 
            return {"history": history,  "chatId": new_chat.data[0]['chat_id'] }

    answer = get_answer(commons, chat_message, user.email, user_openai_api_key)
    history.append(("assistant", answer))
    new_chat = create_chat(user_id, history, chat_name)

    return {"history": history, "chatId": new_chat.data[0]['chat_id'], "chatName":new_chat.data[0]['chat_name'] }``` "/Users/aswin/Documents/quivr/backend/utils/vectors.py" ```import os
from typing import Annotated, List, Tuple
import dotenv
from auth.auth_bearer import JWTBearer
from fastapi import Depends, UploadFile
from langchain.embeddings.openai import OpenAIEmbeddings
from langchain.schema import Document
from langchain.vectorstores import SupabaseVectorStore
from llm.qa import get_qa_llm
from llm.summarization import llm_evaluate_summaries, llm_summerize
from logger import get_logger
from models.chats import ChatMessage
from models.users import User
from pydantic import BaseModel

from supabase import Client, create_client
dotenv.load_dotenv(verbose=True)
logger = get_logger(__name__)
openai_api_key = os.environ.get("OPENAI_API_KEY")
anthropic_api_key = os.environ.get("ANTHROPIC_API_KEY")
supabase_url = os.environ.get("SUPABASE_URL")
supabase_key = os.environ.get("SUPABASE_SERVICE_KEY")
embeddings = OpenAIEmbeddings(openai_api_key=openai_api_key)
supabase_client: Client = create_client(supabase_url, supabase_key)
documents_vector_store = SupabaseVectorStore(
    supabase_client, embeddings, table_name="vectors")
summaries_vector_store = SupabaseVectorStore(
    supabase_client, embeddings, table_name="summaries")
def common_dependencies():
    return {
        "supabase": supabase_client,
        "embeddings": embeddings,
        "documents_vector_store": documents_vector_store,
        "summaries_vector_store": summaries_vector_store
    }
CommonsDep = Annotated[dict, Depends(common_dependencies)]
def create_summary(document_id, content, metadata):
    logger.info(f"Summarizing document {content[:100]}")
    summary = llm_summerize(content)
    logger.info(f"Summary: {summary}")
    metadata['document_id'] = document_id
    summary_doc_with_metadata = Document(
        page_content=summary, metadata=metadata)
    sids = summaries_vector_store.add_documents(
        [summary_doc_with_metadata])
    if sids and len(sids) > 0:
        supabase_client.table("summaries").update(
            {"document_id": document_id}).match({"id": sids[0]}).execute()

def create_vector(user_id,doc, user_openai_api_key=None):
    logger.info(f"Creating vector for document")
    logger.info(f"Document: {doc}")
    if user_openai_api_key:
        documents_vector_store._embedding = embeddings_request = OpenAIEmbeddings(openai_api_key=user_openai_api_key)
    try:
        
        sids = documents_vector_store.add_documents(
            [doc])
        if sids and len(sids) > 0:
            supabase_client.table("vectors").update(
                {"user_id": user_id}).match({"id": sids[0]}).execute()
    except Exception as e:
        logger.error(f"Error creating vector for document {e}")

def create_user(email, date):
    logger.info(f"New user entry in db document for user {email}")

    return(supabase_client.table("users").insert(
        {"email": email, "date": date, "requests_count": 1}).execute())

def update_user_request_count(email, date, requests_count):
    logger.info(f"User {email} request count updated to {requests_count}")
    supabase_client.table("users").update(
        { "requests_count": requests_count}).match({"email": email, "date": date}).execute()

def create_chat(user_id, history, chat_name):
    logger.info(f"New chat entry in chats table for user {user_id}")
    new_chat = {
        "user_id": user_id,
        "history": history,
        "chat_name": chat_name
    }
    insert_response = supabase_client.table('chats').insert(new_chat).execute()
    logger.info(f"Insert response {insert_response.data}")

    return(insert_response)

def update_chat(chat_id, history):
    supabase_client.table("chats").update(
        { "history": history}).match({"chat_id": chat_id}).execute()
    logger.info(f"Chat {chat_id} updated")
    

def create_embedding(content):
    return embeddings.embed_query(content)
def similarity_search(query, table='match_summaries', top_k=5, threshold=0.5):
    query_embedding = create_embedding(query)
    summaries = supabase_client.rpc(
        table, {'query_embedding': query_embedding,
                'match_count': top_k, 'match_threshold': threshold}
    ).execute()
    return summaries.data
def fetch_user_id_from_credentials(commons: CommonsDep,date,credentials):
    user = User(email=credentials.get('email', 'none'))
    response = commons['supabase'].from_('users').select('user_id').filter("email", "eq", user.email).execute()

    userItem = next(iter(response.data or []), {})

    if userItem == {}: 
        create_user_response = create_user(email= user.email, date=date)
        user_id = create_user_response.data[0]['user_id']

    else: 
        user_id = userItem['user_id']
    return user_id

def get_chat_name_from_first_question(chat_message: ChatMessage):
    chat_name = ' '.join(chat_message.question.split()[:3])
    print('chat_name')
    return chat_name
   
def get_answer(commons: CommonsDep,  chat_message: ChatMessage, email: str, user_openai_api_key:str):
    qa = get_qa_llm(chat_message, email, user_openai_api_key)
    if chat_message.use_summarization:
        summaries = similarity_search(
            chat_message.question, table='match_summaries')
        evaluations = llm_evaluate_summaries(
            chat_message.question, summaries, chat_message.model)
        if evaluations:
            reponse = commons['supabase'].from_('vectors').select(
                '*').in_('id', values=[e['document_id'] for e in evaluations]).execute()
            additional_context = '---\nAdditional Context={}'.format(
                '---\n'.join(data['content'] for data in reponse.data)
            ) + '\n'
        model_response = qa(
            {"question": additional_context + chat_message.question})
    else:
        model_response = qa({"question": chat_message.question})

    answer = model_response['answer']
    if "source_documents" in answer:
        sources = [
            doc.metadata["file_name"] for doc in answer["source_documents"]
            if "file_name" in doc.metadata]
        if sources:
            files = dict.fromkeys(sources)
            answer = answer + "\n\nRef: " + "; ".join(files)

    return answer```. "INFO:     127.0.0.1:50823 - "GET /chat HTTP/1.1" 500 Internal Server Error
ERROR:    Exception in ASGI application
Traceback (most recent call last):
  File "/opt/homebrew/lib/python3.11/site-packages/uvicorn/protocols/http/httptools_impl.py", line 435, in run_asgi
    result = await app(  # type: ignore[func-returns-value]
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/homebrew/lib/python3.11/site-packages/uvicorn/middleware/proxy_headers.py", line 78, in __call__
    return await self.app(scope, receive, send)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/homebrew/lib/python3.11/site-packages/fastapi/applications.py", line 276, in __call__
    await super().__call__(scope, receive, send)
  File "/opt/homebrew/lib/python3.11/site-packages/starlette/applications.py", line 122, in __call__
    await self.middleware_stack(scope, receive, send)
  File "/opt/homebrew/lib/python3.11/site-packages/starlette/middleware/errors.py", line 184, in __call__
    raise exc
  File "/opt/homebrew/lib/python3.11/site-packages/starlette/middleware/errors.py", line 162, in __call__
    await self.app(scope, receive, _send)
  File "/opt/homebrew/lib/python3.11/site-packages/starlette/middleware/cors.py", line 91, in __call__
    await self.simple_response(scope, receive, send, request_headers=headers)
  File "/opt/homebrew/lib/python3.11/site-packages/starlette/middleware/cors.py", line 146, in simple_response
    await self.app(scope, receive, send)
  File "/opt/homebrew/lib/python3.11/site-packages/starlette/middleware/exceptions.py", line 79, in __call__
    raise exc
  File "/opt/homebrew/lib/python3.11/site-packages/starlette/middleware/exceptions.py", line 68, in __call__
    await self.app(scope, receive, sender)
  File "/opt/homebrew/lib/python3.11/site-packages/fastapi/middleware/asyncexitstack.py", line 21, in __call__
    raise e
  File "/opt/homebrew/lib/python3.11/site-packages/fastapi/middleware/asyncexitstack.py", line 18, in __call__
    await self.app(scope, receive, send)
  File "/opt/homebrew/lib/python3.11/site-packages/starlette/routing.py", line 718, in __call__
    await route.handle(scope, receive, send)
  File "/opt/homebrew/lib/python3.11/site-packages/starlette/routing.py", line 276, in handle
    await self.app(scope, receive, send)
  File "/opt/homebrew/lib/python3.11/site-packages/starlette/routing.py", line 66, in app
    response = await func(request)
               ^^^^^^^^^^^^^^^^^^^
  File "/opt/homebrew/lib/python3.11/site-packages/fastapi/routing.py", line 237, in app
    raw_response = await run_endpoint_function(
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/homebrew/lib/python3.11/site-packages/fastapi/routing.py", line 163, in run_endpoint_function
    return await dependant.call(**values)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/aswin/Documents/quivr/backend/routes/chat_routes.py", line 24, in get_chats
    response = commons['supabase'].from_('chats').select('chatId:chat_id, chatName:chat_name').filter("user_id", "eq", user_id).execute()
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/homebrew/lib/python3.11/site-packages/postgrest/_sync/request_builder.py", line 68, in execute
    raise APIError(r.json())
postgrest.exceptions.APIError: {'code': '22P02', 'details': None, 'hint': None, 'message': 'invalid input syntax for type uuid: "None"'}".
i get this error when i click chat button. give me correct complete modified python code to resolve this error based on code provided