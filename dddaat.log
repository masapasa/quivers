"backend/routes/chat_routes.py" ```import os
import time
from uuid import UUID
from auth.auth_bearer import AuthBearer, get_current_user
from fastapi import APIRouter, Depends, Request
from llm.brainpicking import BrainPicking
from models.chats import ChatMessage, ChatAttributes
from models.settings import CommonsDep, common_dependencies
from models.users import User
from utils.chats import (create_chat, get_chat_name_from_first_question,
                         update_chat)
from utils.users import (create_user, fetch_user_id_from_credentials,
                         update_user_request_count)
from http.client import HTTPException

chat_router = APIRouter()


def get_user_chats(commons, user_id):
    response = (
        commons["supabase"]
        .from_("chats")
        .select("chatId:chat_id, chatName:chat_name")
        .filter("user_id", "eq", user_id)
        .execute()
    )
    return response.data


def get_chat_details(commons, chat_id):
    response = (
        commons["supabase"]
        .from_("chats")
        .select("*")
        .filter("chat_id", "eq", chat_id)
        .execute()
    )
    return response.data


def delete_chat_from_db(commons, chat_id):
    commons["supabase"].table("chats").delete().match({"chat_id": chat_id}).execute()


def fetch_user_stats(commons, user, date):
    response = (
        commons["supabase"]
        .from_("users")
        .select("*")
        .filter("email", "eq", user.email)
        .filter("date", "eq", date)
        .execute()
    )
    userItem = next(iter(response.data or []), {"requests_count": 0})
    return userItem


# get all chats
@chat_router.get("/chat", dependencies=[Depends(AuthBearer())], tags=["Chat"])
async def get_chats(current_user: User = Depends(get_current_user)):
    commons = common_dependencies()
    user_id = fetch_user_id_from_credentials(commons, {"email": current_user.email})
    chats = get_user_chats(commons, user_id)
    return {"chats": chats}
@chat_router.get("/chat/{chat_id}", dependencies=[Depends(AuthBearer())], tags=["Chat"])
async def get_chat_handler(chat_id: UUID):
    commons = common_dependencies()
    chats = get_chat_details(commons, chat_id)
    if len(chats) > 0:
        return {"chatId": chat_id, "history": chats[0]["history"]}
    else:
        return {"error": "Chat not found"}
@chat_router.delete("/chat/{chat_id}", dependencies=[Depends(AuthBearer())], tags=["Chat"])
async def delete_chat(chat_id: UUID):
    commons = common_dependencies()
    delete_chat_from_db(commons, chat_id)
    return {"message": f"{chat_id}  has been deleted."}
def chat_handler(request, commons, chat_id, chat_message, email, is_new_chat=False):
    date = time.strftime("%Y%m%d")
    user_id = fetch_user_id_from_credentials(commons, {"email": email})
    max_requests_number = os.getenv("MAX_REQUESTS_NUMBER")
    user_openai_api_key = request.headers.get("Openai-Api-Key")

    userItem = fetch_user_stats(commons, User(email=email), date)
    old_request_count = userItem["requests_count"]

    history = chat_message.history
    history.append(("user", chat_message.question))

    chat_name = chat_message.chat_name

    if old_request_count == 0:
        create_user(commons, email=email, date=date)
    else:
        update_user_request_count(
            commons, email, date, requests_count=old_request_count + 1
        )
    if user_openai_api_key is None and old_request_count >= float(max_requests_number):
        history.append(("assistant", "You have reached your requests limit"))
        update_chat(commons, chat_id=chat_id, history=history, chat_name=chat_name)
        return {"history": history}

    brainPicking = BrainPicking().init(chat_message.model, email)
    answer = brainPicking.generate_answer(chat_message, user_openai_api_key)
    history.append(("assistant", answer))

    if is_new_chat:
        chat_name = get_chat_name_from_first_question(chat_message)
        new_chat = create_chat(commons, user_id, history, chat_name)
        chat_id = new_chat.data[0]["chat_id"]
    else:
        update_chat(commons, chat_id=chat_id, history=history, chat_name=chat_name)

    return {"history": history, "chatId": chat_id}
@chat_router.put("/chat/{chat_id}", dependencies=[Depends(AuthBearer())], tags=["Chat"])
async def chat_endpoint(
    request: Request,
    commons: CommonsDep,
    chat_id: UUID,
    chat_message: ChatMessage,
    current_user: User = Depends(get_current_user),
):
    return chat_handler(request, commons, chat_id, chat_message, current_user.email)
@chat_router.put("/chat/{chat_id}/metadata", dependencies=[Depends(AuthBearer())], tags=["Chat"])
async def update_chat_attributes_handler(
    commons: CommonsDep,
    chat_message: ChatAttributes,
    chat_id: UUID,
    current_user: User = Depends(get_current_user),
):
 user_id = fetch_user_id_from_credentials(commons, {"email": current_user.email})
    chat = get_chat_details(commons, chat_id)[0]
    if user_id != chat.get('user_id'):
        raise HTTPException(status_code=403, detail="Chat not owned by user")
    return update_chat(commons=commons, chat_id=chat_id, chat_name=chat_message.chat_name)
@chat_router.post("/chat", dependencies=[Depends(AuthBearer())], tags=["Chat"])
async def create_chat_handler(
    request: Request,
    commons: CommonsDep,
    chat_message: ChatMessage,
    current_user: User = Depends(get_current_user),
):
    return chat_handler(
        request, commons, None, chat_message, current_user.email, is_new_chat=True
    )```"backend/auth/auth_bearer.py" ```import os
from typing import Optional

from auth.api_key_handler import get_user_from_api_key, verify_api_key
from auth.jwt_token_handler import decode_access_token, verify_token
from fastapi import Depends, HTTPException, Request
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from models.settings import CommonsDep
from models.users import User

import dotenv
dotenv.load_dotenv(verbose=True)
class AuthBearer(HTTPBearer):
    def __init__(self, auto_error: bool = True):
        super().__init__(auto_error=auto_error)

    async def __call__(self, request: Request, commons: CommonsDep):
        credentials: Optional[HTTPAuthorizationCredentials] = await super().__call__(
            request
        )
        self.check_scheme(credentials)
        token = credentials.credentials
        return await self.authenticate(token, commons)

    def check_scheme(self, credentials):
        if credentials and not credentials.scheme == "Bearer":
            raise HTTPException(status_code=402, detail="Invalid authorization scheme.")
        elif not credentials:
            raise HTTPException(status_code=403, detail="Invalid authorization code.")

    async def authenticate(self, token: str, commons: CommonsDep):
        if os.environ.get("AUTHENTICATE") == "false":
            return self.get_test_user()
        elif verify_token(token):
            return decode_access_token(token)
        elif await verify_api_key(token, commons):
            return await get_user_from_api_key(token, commons)
        else:
            raise HTTPException(
                status_code=402, detail="Invalid token or expired token."
            )

    def get_test_user(self):
        return {"email": "test@example.com"}
def get_current_user(credentials: dict = Depends(AuthBearer())) -> User:
    return User(email=credentials.get("email", "none"))```"backend/utils/chats.py" ```from logger import get_logger
from models.chats import ChatMessage
from models.settings import CommonsDep

logger = get_logger(__name__)


def create_chat(commons: CommonsDep, user_id, history, chat_name):
    logger.info(f"New chat entry in chats table for user {user_id}")
    new_chat = {
        "user_id": user_id,
        "history": history,
        "chat_name": chat_name,
    }
    insert_response = commons["supabase"].table("chats").insert(new_chat).execute()
    logger.info(f"Insert response {insert_response.data}")

    return insert_response
def update_chat(commons: CommonsDep, chat_id, history=None, chat_name=None):
    if not chat_id:
        logger.error("No chat_id provided")
        return

    updates = {}

    if history is not None:
        updates["history"] = history

    if chat_name is not None:
        updates["chat_name"] = chat_name

    if updates:
        commons["supabase"].table("chats").update(updates).match(
            {"chat_id": chat_id}
        ).execute()
        logger.info(f"Chat {chat_id} updated")
    else:
        logger.info(f"No updates to apply for chat {chat_id}")


def get_chat_name_from_first_question(chat_message: ChatMessage):
    chat_name = " ".join(chat_message.question.split()[:3])
    return chat_name```"backend/utils/users.py" ```import time

from logger import get_logger
from models.settings import CommonsDep
from models.users import User

logger = get_logger(__name__)

def create_user(commons: CommonsDep, email, date):
    logger.info(f"New user entry in db document for user {email}")

    return(commons['supabase'].table("users").insert(
        {"email": email, "date": date, "requests_count": 1}).execute())

def update_user_request_count(commons: CommonsDep, email, date, requests_count):
    logger.info(f"User {email} request count updated to {requests_count}")
    commons['supabase'].table("users").update(
        { "requests_count": requests_count}).match({"email": email, "date": date}).execute()
    
def fetch_user_id_from_credentials(commons: CommonsDep,credentials):
    user = User(email=credentials.get('email', 'none'))
    response = commons['supabase'].from_('users').select('user_id').filter("email", "eq", user.email).execute()

    userItem = next(iter(response.data or []), {})

    if userItem == {}: 
        date = time.strftime("%Y%m%d")
        create_user_response = create_user(commons, email= user.email, date=date)
        user_id = create_user_response.data[0]['user_id']

    else: 
        user_id = userItem['user_id']

    return user_id```. i get this error on the terminal which is running at aws ec2 instance when i click the chat button on the nextjs frontend. "NFO:     127.0.0.1:52470 - "GET /chat HTTP/1.0" 307 Temporary Redirect
INFO:     127.0.0.1:52474 - "GET /brains HTTP/1.0" 404 Not Found
INFO:     127.0.0.1:52484 - "GET /chat/ HTTP/1.0" 405 Method Not Allowed
INFO:     127.0.0.1:53762 - "GET /chat HTTP/1.0" 307 Temporary Redirect
INFO:     127.0.0.1:53770 - "GET /chat/ HTTP/1.0" 405 Method Not Allowed
INFO:     127.0.0.1:53782 - "POST /chat HTTP/1.0" 307 Temporary Redirect
INFO:     127.0.0.1:53794 - "POST /chat/ HTTP/1.0" 500 Internal Server Error
ERROR:    Exception in ASGI application
Traceback (most recent call last):
  File "uvicorn/protocols/http/h11_impl.py", line 428, in run_asgi
    result = await app(  # type: ignore[func-returns-value]
  File "uvicorn/middleware/proxy_headers.py", line 78, in __call__
    return await self.app(scope, receive, send)
  File "fastapi/applications.py", line 282, in __call__
    await super().__call__(scope, receive, send)
  File "starlette/applications.py", line 122, in __call__
    await self.middleware_stack(scope, receive, send)
  File "starlette/middleware/errors.py", line 184, in __call__
    raise exc
  File "starlette/middleware/errors.py", line 162, in __call__
    await self.app(scope, receive, _send)
  File "starlette/middleware/cors.py", line 91, in __call__
    await self.simple_response(scope, receive, send, request_headers=headers)
  File "starlette/middleware/cors.py", line 146, in simple_response
    await self.app(scope, receive, send)
  File "starlette/middleware/exceptions.py", line 79, in __call__
    raise exc
  File "starlette/middleware/exceptions.py", line 68, in __call__
    await self.app(scope, receive, sender)
  File "fastapi/middleware/asyncexitstack.py", line 20, in __call__
    raise e
  File "fastapi/middleware/asyncexitstack.py", line 17, in __call__
    await self.app(scope, receive, send)
  File "starlette/routing.py", line 718, in __call__
    await route.handle(scope, receive, send)
  File "starlette/routing.py", line 276, in handle
    await self.app(scope, receive, send)
  File "starlette/routing.py", line 66, in app
    response = await func(request)
  File "fastapi/routing.py", line 241, in app
    raw_response = await run_endpoint_function(
  File "fastapi/routing.py", line 167, in run_endpoint_function
    return await dependant.call(**values)
  File "/home/ubuntu/quivr/backend/main.py", line 61, in chat_endpoint
    '*').filter("user_id", "eq", user.email).filter("date", "eq", date).execute()
  File "postgrest/_sync/request_builder.py", line 68, in execute
    raise APIError(r.json())
postgrest.exceptions.APIError: {'code': '22P02', 'details': None, 'hint': None, 'message': 'invalid input syntax for type uuid: "apyakurel@gmail.com"'}". identify the error and give me correct complete modified fastapi python code based on the code provided