"frontend/app/(auth)/signup/hooks/useSignUp.ts" ```import { useState } from "react";

import { useSupabase } from "@/lib/context/SupabaseProvider";
import { useToast } from "@/lib/hooks/useToast";
import { useEventTracking } from "@/services/analytics/useEventTracking";

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export const useSignUp = () => {
  const { supabase } = useSupabase();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [subscriptionType, setSubscriptionType] = useState("free");
  const [isPending, setIsPending] = useState(false);
  const { track } = useEventTracking();

  const { publish } = useToast();
  const handleSignUp = async () => {
    void track("SIGNUP");
    setIsPending(true);
    const { error } = await supabase.auth.signUp({
      email: email,
      password: password,
    }, {
      data: { subscription_type: subscriptionType },
    });

    if (error) {
      console.error("Error signing up:", error.message);
      publish({
        variant: "danger",
        text: `Error signing up: ${error.message}`,
      });
    } else {
      publish({
        variant: "success",
        text: "Confirmation Email sent, please check your email",
      });
    }
    setIsPending(false);
  };

  return {
    handleSignUp,
    setEmail,
    password,
    setPassword,
    isPending,
    email,
    subscriptionType,
    setSubscriptionType,
  };
};```"frontend/app/(auth)/signup/page.tsx" ```/* eslint-disable */
"use client";
import Link from "next/link";

import Button from "@/lib/components/ui/Button";
import Card from "@/lib/components/ui/Card";
import Field from "@/lib/components/ui/Field";
import PageHeading from "@/lib/components/ui/PageHeading";
import { useSignUp } from "./hooks/useSignUp";

export default function SignUp() {
  const {
    handleSignUp,
    isPending,
    email,
    password,
    setEmail,
    setPassword,
    subscriptionType,
    setSubscriptionType,
  } = useSignUp();
  const handlePayment = () => {
  };
  

  return (
    <main data-testid="sign-up-page">
      <section className="min-h-[80vh] w-full h-full outline-none flex flex-col gap-5 items-center justify-center p-6">
        <PageHeading title="Sign Up" subtitle="Create your account" />
        <Card className="max-w-md w-full p-5 sm:p-10 text-left">
          <form
            onSubmit={(e) => {
              e.preventDefault();
              handleSignUp();
            }}
            className="flex flex-col gap-2"
            data-testid="sign-up-form"
          >
            <Field
              name="email"
              required
              type="email"
              placeholder="Email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              data-testid="email-field"
            />
            <Field
              name="password"
              required
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Password"
              data-testid="password-field"
            />
            <div className="flex flex-col items-center justify-center mt-2 gap-2">
              <label htmlFor="subscription-type">Choose a plan:</label>
              <select
                id="subscription-type"
                value={subscriptionType}
                onChange={(e) => setSubscriptionType(e.target.value)}
              >
                <option value="free">Free</option>
                <option value="premium">Premium</option>
                <option value="gold">Gold</option>
              </select>
              <Button data-testid="sign-up-button" isLoading={isPending}>
                Sign Up
              </Button>
              <Link href="/login">Already registered? Sign in</Link>
            </div>
          </form>
        </Card>
      </section>
    </main>
  );
}```"frontend/app/(auth)/login/components/MagicLinkLogin/hooks/useMagicLinkLogin.ts" ```import { useState } from "react";

type UseMagicLinkLoginProps = {
  email: string;
  setEmail: (email: string) => void;
};

import { useSupabase } from "@/lib/context/SupabaseProvider";
import { useToast } from "@/lib/hooks";

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export const useMagicLinkLogin = ({
  email,
  setEmail,
}: UseMagicLinkLoginProps) => {
  const { supabase } = useSupabase();
  const [isPending, setIsPending] = useState(false);

  const { publish } = useToast();

  const handleMagicLinkLogin = async () => {
    if (email === "") {
      publish({
        variant: "danger",
        text: "Please enter your email address",
      });

      return;
    }

    setIsPending(true);

    const { error } = await supabase.auth.signInWithOtp({
      email,
      options: {
        emailRedirectTo: window.location.hostname,
      },
    });

    if (error) {
      publish({
        variant: "danger",
        text: error.message,
      });
    } else {
      publish({
        variant: "success",
        text: "Magic link sent successfully if email recognized",
      });

      setEmail("");
    }
    setIsPending(false);
  };

  return { handleMagicLinkLogin, isPending };
};```"frontend/app/(auth)/login/components/MagicLinkLogin/index.tsx" ```"use client";

import Button from "@/lib/components/ui/Button";

import { useMagicLinkLogin } from "./hooks/useMagicLinkLogin";

type MaginLinkLoginProps = {
  email: string;
  setEmail: (email: string) => void;
};

export const MagicLinkLogin = ({
  email,
  setEmail,
}: MaginLinkLoginProps): JSX.Element => {
  const { handleMagicLinkLogin, isPending } = useMagicLinkLogin({
    email,
    setEmail,
  });

  return (
    <Button
      type="button"
      variant={"tertiary"}
      onClick={() => void handleMagicLinkLogin()}
      isLoading={isPending}
    >
      Send Magic Link
    </Button>
  );
};```"frontend/app/(auth)/login/hooks/useLogin.ts" ```import { redirect } from "next/navigation";
import { useEffect, useState } from "react";

import { useSupabase } from "@/lib/context/SupabaseProvider";
import { useToast } from "@/lib/hooks";
import { useEventTracking } from "@/services/analytics/useEventTracking";

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export const useLogin = () => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isPending, setIsPending] = useState(false);
  const { publish } = useToast();
  const { supabase, session } = useSupabase();

  const { track } = useEventTracking();

  const handleLogin = async () => {
    setIsPending(true);
    const { error } = await supabase.auth.signInWithPassword({
      email: email,
      password: password,
    });

    if (error) {
      publish({
        variant: "danger",
        text: error.message,
      });
    } else {
      publish({
        variant: "success",
        text: "Successfully logged in",
      });
    }
    setIsPending(false);
  };

  useEffect(() => {
    if (session?.user !== undefined) {
      void track("SIGNED_IN");

      const previousPage = sessionStorage.getItem("previous-page");
      if (previousPage === null) {
        redirect("/upload");
      } else {
        sessionStorage.removeItem("previous-page");
        redirect(previousPage);
      }
    }
  }, [session?.user]);

  return {
    handleLogin,
    setEmail,
    setPassword,
    email,
    isPending,
    password,
  };
};```"frontend/app/(auth)/login/page.tsx" ```/* eslint-disable */
"use client";
import Link from "next/link";

import Button from "@/lib/components/ui/Button";
import Card from "@/lib/components/ui/Card";
import { Divider } from "@/lib/components/ui/Divider";
import Field from "@/lib/components/ui/Field";
import PageHeading from "@/lib/components/ui/PageHeading";

import { GoogleLoginButton } from "./components/GoogleLogin";
import { MagicLinkLogin } from "./components/MagicLinkLogin";
import { PasswordForgotten } from "./components/PasswordForgotten";
import { useLogin } from "./hooks/useLogin";

export default function Login() {
  const { handleLogin, setEmail, setPassword, email, isPending, password } =
    useLogin();

  return (
    <main>
      <section className="w-full min-h-[80vh] h-full outline-none flex flex-col gap-5 items-center justify-center p-6">
        <PageHeading title="Login" subtitle="Welcome back" />
        <Card className="max-w-md w-full p-5 sm:p-10 text-left">
          <form
            data-testid="sign-in-form"
            onSubmit={(e) => {
              e.preventDefault();
              handleLogin();
            }}
            className="flex flex-col gap-2"
          >
            <Field
              name="email"
              required
              type="email"
              placeholder="Email"
              onChange={(e) => setEmail(e.target.value)}
              value={email}
            />
            <Field
              name="password"
              required
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Password"
            />

            <div className="flex flex-col items-center justify-center mt-2 gap-2">
              <Button type="submit" isLoading={isPending}>
                Login
              </Button>
              <PasswordForgotten setEmail={setEmail} email={email} />

              <Link href="/signup">Don{"'"}t have an account? Sign up</Link>
            </div>

            <Divider text="or" />
            <div className="flex flex-col items-center justify-center mt-2 gap-2">
              <GoogleLoginButton />
            </div>
            <Divider text="or" />
            <MagicLinkLogin email={email} setEmail={setEmail} />
          </form>
        </Card>
      </section>
    </main>
  );
}```. this is how signup is handled in the nextjs frontend. "/Users/aswin/Documents/quivr/backend/core/auth/__init__.py" ```from .auth_bearer import AuthBearer, get_current_user

__all__ = [
    "AuthBearer",
    "get_current_user",
]
```
"/Users/aswin/Documents/quivr/backend/core/auth/api_key_handler.py" ```from datetime import datetime

from fastapi import HTTPException
from models.settings import common_dependencies
from models.users import User
from pydantic import DateError


async def verify_api_key(
    api_key: str,
) -> bool:
    try:
        # Use UTC time to avoid timezone issues
        current_date = datetime.utcnow().date()
        commons = common_dependencies()
        result = (
            commons["supabase"]
            .table("api_keys")
            .select("api_key", "creation_time")
            .filter("api_key", "eq", api_key)
            .filter("is_active", "eq", True)
            .execute()
        )
        if result.data is not None and len(result.data) > 0:
            api_key_creation_date = datetime.strptime(
                result.data[0]["creation_time"], "%Y-%m-%dT%H:%M:%S"
            ).date()

            # Check if the API key was created in the month of the current date
            if (api_key_creation_date.month == current_date.month) and (
                api_key_creation_date.year == current_date.year
            ):
                return True
        return False
    except DateError:
        return False


async def get_user_from_api_key(
    api_key: str,
) -> User:
    commons = common_dependencies()

    # Lookup the user_id from the api_keys table
    user_id_data = (
        commons["supabase"]
        .table("api_keys")
        .select("user_id")
        .filter("api_key", "eq", api_key)
        .execute()
    )

    if not user_id_data.data:
        raise HTTPException(status_code=400, detail="Invalid API key.")

    user_id = user_id_data.data[0]["user_id"]

    # Lookup the email from the users table. Todo: remove and use user_id for credentials
    user_email_data = (
        commons["supabase"]
        .table("users")
        .select("email")
        .filter("user_id", "eq", user_id)
        .execute()
    )

    email = user_email_data.data[0]["email"] if user_email_data.data else None

    return User(email=email, id=user_id)
```
"/Users/aswin/Documents/quivr/backend/core/auth/auth_bearer.py" ```import os
from typing import Optional
from auth.api_key_handler import get_user_from_api_key, verify_api_key
from auth.jwt_token_handler import decode_access_token, verify_token
from fastapi import Depends, HTTPException, Request
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from models.users import User

class AuthBearer(HTTPBearer):
    def __init__(self, auto_error: bool = True):
        super().__init__(auto_error=auto_error)

    async def __call__(
        self,
        request: Request,
    ):
        credentials: Optional[HTTPAuthorizationCredentials] = await super().__call__(
            request
        )
        self.check_scheme(credentials)
        token = credentials.credentials  # pyright: ignore reportPrivateUsage=none
        return await self.authenticate(
            token,
        )

    def check_scheme(self, credentials):
        if credentials and credentials.scheme != "Bearer":
            raise HTTPException(status_code=401, detail="Token must be Bearer")
        elif not credentials:
            raise HTTPException(
                status_code=403, detail="Authentication credentials missing"
            )

    async def authenticate(
        self,
        token: str,
    ) -> User:
        if os.environ.get("AUTHENTICATE") == "false":
            return self.get_test_user()
        elif verify_token(token):
            return decode_access_token(token)
        elif await verify_api_key(
            token,
        ):
            return await get_user_from_api_key(
                token,
            )
        else:
            raise HTTPException(status_code=401, detail="Invalid token or api key.")

    def get_test_user(self) -> User:
        return User(
            email="test@example.com", id="XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"  # type: ignore
        )  # replace with test user information


def get_current_user(user: User = Depends(AuthBearer())) -> User:
    return user
```
"/Users/aswin/Documents/quivr/backend/core/auth/jwt_token_handler.py" ```import os
from datetime import datetime, timedelta
from typing import Optional
import dotenv
from jose import jwt
from jose.exceptions import JWTError
dotenv.load_dotenv(verbose=True)
from models.users import User
dotenv.load_dotenv(verbose=True)
SECRET_KEY = os.environ.get("JWT_SECRET_KEY")
ALGORITHM = "HS256"

if not SECRET_KEY:
    raise ValueError("JWT_SECRET_KEY environment variable not set")


def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


def decode_access_token(token: str) -> User:
    try:
        payload = jwt.decode(
            token, SECRET_KEY, algorithms=[ALGORITHM], options={"verify_aud": False}
        )
    except JWTError:
        return None  # pyright: ignore reportPrivateUsage=none

    return User(
        email=payload.get("email"),
        id=payload.get("sub"),  # pyright: ignore reportPrivateUsage=none
    )


def verify_token(token: str):
    payload = decode_access_token(token)
    return payload is not None
``` "backend/core/routes/authorizations/brain_authorization.py" ```from enum import Enum
from typing import List, Optional, Union
from uuid import UUID

from auth.auth_bearer import get_current_user
from fastapi import Depends, HTTPException, status
from models.brains import Brain
from models.users import User


class RoleEnum(str, Enum):
    Viewer = "Viewer"
    Editor = "Editor"
    Owner = "Owner"


def has_brain_authorization(
    required_roles: Optional[Union[RoleEnum, List[RoleEnum]]] = RoleEnum.Owner
):
    async def wrapper(brain_id: UUID, current_user: User = Depends(get_current_user)):
        nonlocal required_roles
        if isinstance(required_roles, str):
            required_roles = [required_roles]
        validate_brain_authorization(
            brain_id=brain_id, user_id=current_user.id, required_roles=required_roles
        )

    return wrapper


def validate_brain_authorization(
    brain_id: UUID,
    user_id: UUID,
    required_roles: Optional[Union[RoleEnum, List[RoleEnum]]] = RoleEnum.Owner,
):
    if required_roles is None:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Missing required role",
        )

    brain = Brain(id=brain_id)
    user_brain = brain.get_brain_for_user(user_id)
    if user_brain is None:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="You don't have permission for this brain",
        )
    if isinstance(required_roles, str):
        required_roles = [required_roles]
    if user_brain.get("rights") not in required_roles:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="You don't have the required role(s) for this brain",
        )```"backend/core/routes/api_key_routes.py" ```from datetime import datetime
from secrets import token_hex
from typing import List
from uuid import uuid4

from asyncpg.exceptions import UniqueViolationError
from auth import AuthBearer, get_current_user
from fastapi import APIRouter, Depends
from logger import get_logger
from models.settings import CommonsDep
from models.users import User
from pydantic import BaseModel

logger = get_logger(__name__)


class ApiKeyInfo(BaseModel):
    key_id: str
    creation_time: str


class ApiKey(BaseModel):
    api_key: str
    key_id: str


api_key_router = APIRouter()


@api_key_router.post(
    "/api-key",
    response_model=ApiKey,
    dependencies=[Depends(AuthBearer())],
    tags=["API Key"],
)
async def create_api_key(
    commons: CommonsDep, current_user: User = Depends(get_current_user)
):
    new_key_id = uuid4()
    new_api_key = token_hex(16)
    api_key_inserted = False

    while not api_key_inserted:
        try:
            commons["supabase"].table("api_keys").insert(
                [
                    {
                        "key_id": str(new_key_id),
                        "user_id": str(current_user.id),
                        "api_key": str(new_api_key),
                        "creation_time": datetime.utcnow().strftime(
                            "%Y-%m-%d %H:%M:%S"
                        ),
                        "is_active": True,
                    }
                ]
            ).execute()

            api_key_inserted = True

        except UniqueViolationError:
            new_api_key = token_hex(16)
        except Exception as e:
            logger.error(f"Error creating new API key: {e}")
            return {"api_key": "Error creating new API key."}
    logger.info(f"Created new API key for user {current_user.email}.")

    return {"api_key": new_api_key, "key_id": str(new_key_id)}


@api_key_router.delete(
    "/api-key/{key_id}", dependencies=[Depends(AuthBearer())], tags=["API Key"]
)
async def delete_api_key(
    key_id: str, commons: CommonsDep, current_user: User = Depends(get_current_user)
):
    commons["supabase"].table("api_keys").update(
        {
            "is_active": False,
            "deleted_time": datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S"),
        }
    ).match({"key_id": key_id, "user_id": current_user.id}).execute()

    return {"message": "API key deleted."}


@api_key_router.get(
    "/api-keys",
    response_model=List[ApiKeyInfo],
    dependencies=[Depends(AuthBearer())],
    tags=["API Key"],
)
async def get_api_keys(
    commons: CommonsDep, current_user: User = Depends(get_current_user)
):
    response = (
        commons["supabase"]
        .table("api_keys")
        .select("key_id, creation_time")
        .filter("user_id", "eq", current_user.id)
        .filter("is_active", "eq", True)
        .execute()
    )
    return response.data```. this is how signup login authorizations is handled in the fastapi python backend. "CheckoutForm.js" ```import {useStripe, useElements, PaymentElement} from '@stripe/react-stripe-js';

const CheckoutForm = () => {
  const stripe = useStripe();
  const elements = useElements();

  const handleSubmit = async (event) => {
    // We don't want to let default form submission happen here,
    // which would refresh the page.
    event.preventDefault();

    if (!stripe || !elements) {
      // Stripe.js hasn't yet loaded.
      // Make sure to disable form submission until Stripe.js has loaded.
      return;
    }

    const result = await stripe.confirmPayment({
      //`Elements` instance that was used to create the Payment Element
      elements,
      confirmParams: {
        return_url: "https://example.com/order/123/complete",
      },
    });

    if (result.error) {
      // Show error to your customer (for example, payment details incomplete)
      console.log(result.error.message);
    } else {
      // Your customer will be redirected to your `return_url`. For some payment
      // methods like iDEAL, your customer will be redirected to an intermediate
      // site first to authorize the payment, then redirected to the `return_url`.
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <PaymentElement />
      <button disabled={!stripe}>Submit</button>
    </form>
  )
};

export default CheckoutForm;```. this is an example for impletemnting payment with nextjs javascript in the frontend. i would like to implement premium and gold user signup with payment details. think through the fastapi python backend and nextjs javascript frontend code structure. is it best to implement payment and checkout in the nextjs frontend and update the subscription_type in user table? and then for brain creation and file upload implement the logic based on the subscription type? give me only complete correct nextjs javascript frontend or fastapi python backend code as you see fit