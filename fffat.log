"/Users/aswin/Documents/quivr/frontend/app/(auth)/login/page.tsx" ```/* eslint-disable */
"use client";
import Link from "next/link";

import Button from "@/lib/components/ui/Button";
import Card from "@/lib/components/ui/Card";
import { Divider } from "@/lib/components/ui/Divider";
import Field from "@/lib/components/ui/Field";
import PageHeading from "@/lib/components/ui/PageHeading";

import { GoogleLoginButton } from "./components/GoogleLogin";
import { MagicLinkLogin } from "./components/MagicLinkLogin";
import { PasswordForgotten } from "./components/PasswordForgotten";
import { useLogin } from "./hooks/useLogin";

export default function Login() {
  const { handleLogin, setEmail, setPassword, email, isPending, password } =
    useLogin();

  return (
    <main>
      <section className="w-full min-h-[80vh] h-full outline-none flex flex-col gap-5 items-center justify-center p-6">
        <PageHeading title="Login" subtitle="Welcome back" />
        <Card className="max-w-md w-full p-5 sm:p-10 text-left">
          <form
            data-testid="sign-in-form"
            onSubmit={(e) => {
              e.preventDefault();
              handleLogin();
            }}
            className="flex flex-col gap-2"
          >
            <Field
              name="email"
              required
              type="email"
              placeholder="Email"
              onChange={(e) => setEmail(e.target.value)}
              value={email}
            />
            <Field
              name="password"
              required
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Password"
            />

            <div className="flex flex-col items-center justify-center mt-2 gap-2">
              <Button type="submit" isLoading={isPending}>
                Login
              </Button>
              <PasswordForgotten setEmail={setEmail} email={email} />

              <Link href="/signup">Don{"'"}t have an account? Sign up</Link>
            </div>

            <Divider text="or" />
            <div className="flex flex-col items-center justify-center mt-2 gap-2">
              <GoogleLoginButton />
            </div>
            <Divider text="or" />
            <MagicLinkLogin email={email} setEmail={setEmail} />
          </form>
        </Card>
      </section>
    </main>
  );
}
```
"/Users/aswin/Documents/quivr/frontend/app/(auth)/login/components/PasswordForgotten/index.tsx" ```/* eslint-disable */
"use client";

import Button from "@/lib/components/ui/Button";
import { usePasswordForgotten } from "./hooks/usePasswordForgotten";

type PasswordForgottenProps = {
  email: string;
  setEmail: (email: string) => void;
};

export const PasswordForgotten = ({
  email,
  setEmail,
}: PasswordForgottenProps) => {
  const { isPending, handleRecoverPassword } = usePasswordForgotten({
    email,
    setEmail,
  });
  return (
    <Button
      type="button"
      variant={"tertiary"}
      onClick={handleRecoverPassword}
      isLoading={isPending}
    >
      Password forgotten
    </Button>
  );
};
```
"/Users/aswin/Documents/quivr/frontend/app/(auth)/login/components/PasswordForgotten/hooks/usePasswordForgotten.ts" ```import { useState } from "react";

import { useSupabase } from "@/lib/context/SupabaseProvider";
import { useToast } from "@/lib/hooks";

type UsePasswordForgottenProps = {
  email: string;
  setEmail: (email: string) => void;
};
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export const usePasswordForgotten = ({
  email,
  setEmail,
}: UsePasswordForgottenProps) => {
  const [isPending, setIsPending] = useState(false);
  const { supabase } = useSupabase();

  const { publish } = useToast();

  const handleRecoverPassword = async () => {
    if (email === "") {
      publish({
        variant: "danger",
        text: "Please enter your email address",
      });

      return;
    }

    setIsPending(true);

    const { error } = await supabase.auth.resetPasswordForEmail(email, {
      redirectTo: `${window.location.origin}/recover-password`,
    });

    if (error) {
      publish({
        variant: "danger",
        text: error.message,
      });
    } else {
      publish({
        variant: "success",
        text: "Recovery mail will be sent if email recognized",
      });

      setEmail("");
    }
    setIsPending(false);
  };

  return {
    isPending,
    handleRecoverPassword,
  };
};
```
"/Users/aswin/Documents/quivr/frontend/app/(auth)/login/components/PasswordForgotten/hooks/__tests__/usePassword.test.ts" ```import { act, renderHook } from "@testing-library/react";
import { describe, expect, it, vi } from "vitest";

import { usePasswordForgotten } from "../usePasswordForgotten";

const mockResetPasswordForEmail = vi.fn(() => ({ error: null }));

const mockUseSupabase = () => ({
  supabase: {
    auth: {
      resetPasswordForEmail: mockResetPasswordForEmail,
    },
  },
});

vi.mock("@/lib/context/SupabaseProvider", () => ({
  useSupabase: () => mockUseSupabase(),
}));

const setEmail = vi.fn();

describe("usePassword", () => {
  it("should not call resetPasswordForEmail if email is empty", async () => {
    const { result } = renderHook(() =>
      usePasswordForgotten({
        email: "",
        setEmail,
      })
    );

    await act(() => result.current.handleRecoverPassword());
    expect(mockResetPasswordForEmail).toHaveBeenCalledTimes(0);
  });

  it("should call resetPasswordForEmail with proper arguments", async () => {
    const email = "user@quivr.app";
    const { result } = renderHook(() =>
      usePasswordForgotten({
        email,
        setEmail,
      })
    );

    await act(() => result.current.handleRecoverPassword());
    expect(mockResetPasswordForEmail).toHaveBeenCalledTimes(1);
    expect(mockResetPasswordForEmail).toHaveBeenCalledWith(email, {
      redirectTo: `${window.location.origin}/recover-password`,
    });
  });
});
```
"/Users/aswin/Documents/quivr/frontend/app/(auth)/login/components/MagicLinkLogin/index.tsx" ```"use client";

import Button from "@/lib/components/ui/Button";

import { useMagicLinkLogin } from "./hooks/useMagicLinkLogin";

type MaginLinkLoginProps = {
  email: string;
  setEmail: (email: string) => void;
};

export const MagicLinkLogin = ({
  email,
  setEmail,
}: MaginLinkLoginProps): JSX.Element => {
  const { handleMagicLinkLogin, isPending } = useMagicLinkLogin({
    email,
    setEmail,
  });

  return (
    <Button
      type="button"
      variant={"tertiary"}
      onClick={() => void handleMagicLinkLogin()}
      isLoading={isPending}
    >
      Send Magic Link
    </Button>
  );
};
```
"/Users/aswin/Documents/quivr/frontend/app/(auth)/login/components/MagicLinkLogin/hooks/useMagicLinkLogin.ts" ```import { useState } from "react";

type UseMagicLinkLoginProps = {
  email: string;
  setEmail: (email: string) => void;
};

import { useSupabase } from "@/lib/context/SupabaseProvider";
import { useToast } from "@/lib/hooks";

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export const useMagicLinkLogin = ({
  email,
  setEmail,
}: UseMagicLinkLoginProps) => {
  const { supabase } = useSupabase();
  const [isPending, setIsPending] = useState(false);

  const { publish } = useToast();

  const handleMagicLinkLogin = async () => {
    if (email === "") {
      publish({
        variant: "danger",
        text: "Please enter your email address",
      });

      return;
    }

    setIsPending(true);

    const { error } = await supabase.auth.signInWithOtp({
      email,
      options: {
        emailRedirectTo: window.location.hostname, // current domain name. for eg localhost:3000, localhost:3001, https://...
      },
    });

    if (error) {
      publish({
        variant: "danger",
        text: error.message,
      });
    } else {
      publish({
        variant: "success",
        text: "Magic link sent successfully if email recognized",
      });

      setEmail("");
    }
    setIsPending(false);
  };

  return { handleMagicLinkLogin, isPending };
};
```
"/Users/aswin/Documents/quivr/frontend/app/(auth)/login/components/MagicLinkLogin/hooks/__tests__/useMagicLinkLogin.test.ts" ```import { act, renderHook } from "@testing-library/react";
import { describe, expect, it, vi } from "vitest";

import { useMagicLinkLogin } from "../useMagicLinkLogin";

const mockSignInWithOtp = vi.fn(() => ({ error: null }));

const mockUseSupabase = () => ({
  supabase: {
    auth: {
      signInWithOtp: mockSignInWithOtp,
    },
  },
});

vi.mock("@/lib/context/SupabaseProvider", () => ({
  useSupabase: () => mockUseSupabase(),
}));
const setEmail = vi.fn();

describe("useMagicLinkLogin", () => {
  it("should not call signInWithOtp if email is empty", async () => {
    const { result } = renderHook(() =>
      useMagicLinkLogin({
        email: "",
        setEmail,
      })
    );
    await act(() => result.current.handleMagicLinkLogin());
    expect(mockSignInWithOtp).toHaveBeenCalledTimes(0);
  });

  it("should call signInWithOtp with proper arguments", async () => {
    const email = "user@quivr.app";
    const { result } = renderHook(() =>
      useMagicLinkLogin({
        email,
        setEmail,
      })
    );
    await result.current.handleMagicLinkLogin();
    expect(mockSignInWithOtp).toHaveBeenCalledTimes(1);
    expect(mockSignInWithOtp).toHaveBeenCalledWith({
      email,
      options: { emailRedirectTo: window.location.hostname },
    });
  });
});
```
"/Users/aswin/Documents/quivr/frontend/app/(auth)/login/components/GoogleLogin/index.tsx" ```/* eslint-disable */
import Button from "@/lib/components/ui/Button";

import { useGoogleLogin } from "./hooks/useGoogleLogin";

export const GoogleLoginButton = () => {
  const { isPending, signInWithGoogle } = useGoogleLogin();

  return (
    <Button
      onClick={signInWithGoogle}
      isLoading={isPending}
      variant={"danger"}
      type="button"
      data-testid="google-login-button"
    >
      Login with Google
    </Button>
  );
};
```
"/Users/aswin/Documents/quivr/frontend/app/(auth)/login/components/GoogleLogin/__tests__/GoogleLogin.test.tsx" ```import { fireEvent, render } from "@testing-library/react";
import { describe, expect, it, vi } from "vitest";

import { GoogleLoginButton } from "..";

//Mocking related hooks
const mockUseGoogleLogin = vi.fn(() => ({
  isPending: false,
  signInWithGoogle: vi.fn(),
}));

vi.mock("../hooks/useGoogleLogin", () => ({
  useGoogleLogin: () => mockUseGoogleLogin(),
}));

describe.concurrent("GoogleLoginButton", () => {
  it("renders correctly", () => {
    const { getByTestId } = render(<GoogleLoginButton />);

    const loginButton = getByTestId("google-login-button");

    expect(loginButton).toBeDefined();
  });

  it("calls signInWithGoogle on button click", () => {
    const mockSignInWithGoogle = vi.fn();
    mockUseGoogleLogin.mockReturnValue({
      isPending: false,
      signInWithGoogle: mockSignInWithGoogle,
    });

    const { getByTestId } = render(<GoogleLoginButton />);
    const loginButton = getByTestId("google-login-button");
    fireEvent.click(loginButton);

    expect(mockSignInWithGoogle).toHaveBeenCalledTimes(1);
  });

  it("doesn't call signInWithGoogle on button click when pending", () => {
    const mockSignInWithGoogle = vi.fn();
    mockUseGoogleLogin.mockReturnValue({
      isPending: true,
      signInWithGoogle: mockSignInWithGoogle,
    });

    const { getByTestId } = render(<GoogleLoginButton />);
    const loginButton = getByTestId("google-login-button");
    fireEvent.click(loginButton);

    expect(mockSignInWithGoogle).toHaveBeenCalledTimes(0);
  });
});
```
"/Users/aswin/Documents/quivr/frontend/app/(auth)/login/components/GoogleLogin/hooks/useGoogleLogin.ts" ```/* eslint-disable */
import { useState } from "react";

import { useSupabase } from "@/lib/context/SupabaseProvider";
import { useToast } from "@/lib/hooks/useToast";

export const useGoogleLogin = () => {
  const { supabase } = useSupabase();

  const { publish } = useToast();

  const [isPending, setIsPending] = useState(false);

  const signInWithGoogle = async () => {
    const { error } = await supabase.auth.signInWithOAuth({
      provider: "google",
      options: {
        queryParams: {
          access_type: "offline",
          prompt: "consent",
        },
      },
    });
    setIsPending(false);
    if (error) {
      publish({
        variant: "danger",
        text: "An error occurred ",
      });
    }
  };

  return {
    signInWithGoogle,
    isPending,
  };
};
```
"/Users/aswin/Documents/quivr/frontend/app/(auth)/login/components/GoogleLogin/hooks/__tests__/useGoogleLogin.test.ts" ```import { renderHook } from "@testing-library/react";
import { describe, expect, it, vi } from "vitest";

import { useGoogleLogin } from "../useGoogleLogin";

const mockSignInWithOAuth = vi.fn(() => ({ error: null }));

const mockUseSupabase = () => ({
  supabase: {
    auth: {
      signInWithOAuth: mockSignInWithOAuth,
    },
  },
});

vi.mock("@/lib/context/SupabaseProvider", () => ({
  useSupabase: () => mockUseSupabase(),
}));

describe("useGoogleLogin", () => {
  it("should call signInWithOAuth", async () => {
    const { result } = renderHook(() => useGoogleLogin());

    await result.current.signInWithGoogle();

    expect(mockSignInWithOAuth).toHaveBeenCalledTimes(1);
  });
});
```
"/Users/aswin/Documents/quivr/frontend/app/(auth)/login/__tests__/page.test.tsx" ```import { render } from "@testing-library/react";
import { afterEach, describe, expect, it, vi } from "vitest";

import Login from "../page";

const mockRedirect = vi.fn((url: string) => ({ url }));

vi.mock("next/navigation", () => ({
  redirect: (url: string) => mockRedirect(url),
}));

const mockUseSupabase = vi.fn(() => ({
  session: {
    user: {},
  },
}));

vi.mock("@/lib/context/SupabaseProvider", () => ({
  useSupabase: () => mockUseSupabase(),
}));

vi.mock("@/services/analytics/useEventTracking", () => ({
  useEventTracking: () => ({ track: vi.fn() }),
}));

describe("Login component", () => {
  afterEach(() => {
    vi.clearAllMocks();
  });

  it("redirects to /upload if user is already signed in and is not coming from another page", () => {
    render(<Login />);
    expect(mockRedirect).toHaveBeenCalledTimes(1);
    expect(mockRedirect).toHaveBeenCalledWith("/upload");
  });

  it('redirects to "/previous-page" if user is already signed in and previous page is set', () => {
    const currentPage = "/my-awesome-page";

    Object.defineProperty(window, "location", {
      value: { pathname: currentPage },
    });

    const sessionStorageData: Record<string, string> = {
      "previous-page": currentPage,
    };

    const sessionStorageMock = {
      getItem: vi.fn((key: string) => sessionStorageData[key]),
      setItem: vi.fn(
        (key: string, value: string) => (sessionStorageData[key] = value)
      ),
      removeItem: vi.fn((key: string) => delete sessionStorageData[key]),
    };

    Object.defineProperty(window, "sessionStorage", {
      value: sessionStorageMock,
    });

    render(<Login />);
    expect(mockRedirect).toHaveBeenCalledTimes(1);
    expect(mockRedirect).toHaveBeenCalledWith(currentPage);
  });

  it("should render the login form when user is not signed in", () => {
    mockUseSupabase.mockReturnValue({
      //@ts-expect-error doing this for testing purposes
      session: { user: undefined },
    });
    const { getByTestId } = render(<Login />);
    const signInForm = getByTestId("sign-in-form");
    expect(signInForm).toBeDefined();
  });
});
```
"/Users/aswin/Documents/quivr/frontend/app/(auth)/login/hooks/useLogin.ts" ```import { redirect } from "next/navigation";
import { useEffect, useState } from "react";

import { useSupabase } from "@/lib/context/SupabaseProvider";
import { useToast } from "@/lib/hooks";
import { useEventTracking } from "@/services/analytics/useEventTracking";

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export const useLogin = () => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isPending, setIsPending] = useState(false);
  const { publish } = useToast();
  const { supabase, session } = useSupabase();

  const { track } = useEventTracking();

  const handleLogin = async () => {
    setIsPending(true);
    const { error } = await supabase.auth.signInWithPassword({
      email: email,
      password: password,
    });

    if (error) {
      publish({
        variant: "danger",
        text: error.message,
      });
    } else {
      publish({
        variant: "success",
        text: "Successfully logged in",
      });
    }
    setIsPending(false);
  };

  useEffect(() => {
    if (session?.user !== undefined) {
      void track("SIGNED_IN");

      const previousPage = sessionStorage.getItem("previous-page");
      if (previousPage === null) {
        redirect("/upload");
      } else {
        sessionStorage.removeItem("previous-page");
        redirect(previousPage);
      }
    }
  }, [session?.user]);

  return {
    handleLogin,
    setEmail,
    setPassword,
    email,
    isPending,
    password,
  };
};
```
"/Users/aswin/Documents/quivr/frontend/app/(auth)/login/hooks/__tests__/useLogin.test.ts" ```import { act, renderHook } from "@testing-library/react";
import { describe, expect, it, vi } from "vitest";

import { useLogin } from "../useLogin";

const mockSignInWithPassword = vi.fn(() => ({ error: null }));

const mockUseSupabase = () => ({
  supabase: {
    auth: {
      signInWithPassword: mockSignInWithPassword,
    },
  },
});

vi.mock("@/lib/context/SupabaseProvider", () => ({
  useSupabase: () => mockUseSupabase(),
}));

describe("useLogin", () => {
  it("should call signInWithPassword with user email and password", async () => {
    const { result } = renderHook(() => useLogin());

    const email = "user@quivr.com";
    const password = "password";

    act(() => result.current.setEmail(email));
    act(() => result.current.setPassword(password));

    await act(() => result.current.handleLogin());

    expect(mockSignInWithPassword).toHaveBeenCalledTimes(1);
    expect(mockSignInWithPassword).toHaveBeenCalledWith({
      email,
      password,
    });
  });
});
``` "/Users/aswin/Documents/quivr/frontend/app/(auth)/signup/page.tsx" ```/* eslint-disable */
"use client";
import Link from "next/link";

import Button from "@/lib/components/ui/Button";
import Card from "@/lib/components/ui/Card";
import Field from "@/lib/components/ui/Field";
import PageHeading from "@/lib/components/ui/PageHeading";
import { useSignUp } from "./hooks/useSignUp";

export default function SignUp() {
  const { handleSignUp, isPending, email, password, setEmail, setPassword } =
    useSignUp();
  return (
    <main data-testid="sign-up-page">
      <section className="min-h-[80vh] w-full h-full outline-none flex flex-col gap-5 items-center justify-center p-6">
        <PageHeading title="Sign Up" subtitle="Create your account" />
        <Card className="max-w-md w-full p-5 sm:p-10 text-left">
          <form
            onSubmit={(e) => {
              e.preventDefault();
              handleSignUp();
            }}
            className="flex flex-col gap-2"
            data-testid="sign-up-form"
          >
            <Field
              name="email"
              required
              type="email"
              placeholder="Email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              data-testid="email-field"
            />
            <Field
              name="password"
              required
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              placeholder="Password"
              data-testid="password-field"
            />
            <div className="flex flex-col items-center justify-center mt-2 gap-2">
              <Button data-testid="sign-up-button" isLoading={isPending}>
                Sign Up
              </Button>
              <Link href="/login">Already registered? Sign in</Link>
            </div>
          </form>
        </Card>
      </section>
    </main>
  );
}
```
"/Users/aswin/Documents/quivr/frontend/app/(auth)/signup/__tests__/page.test.tsx" ```import { fireEvent, render } from "@testing-library/react";
import { describe, expect, it, vi } from "vitest";

import SignUp from "../page";

const mockHandleSignUp = vi.fn(() => ({}));

vi.mock("next/navigation", () => ({
  useRouter: () => ({ replace: vi.fn() }),
}));

vi.mock("@/lib/context/SupabaseProvider", () => ({
  useSupabase: () => ({}),
}));

describe("SignUp component", () => {
  it("should render correctly", () => {
    const { getByTestId } = render(<SignUp />);
    const signUpPage = getByTestId("sign-up-page");
    expect(signUpPage).toBeDefined();

    const signUpForm = getByTestId("sign-up-form");
    expect(signUpForm).toBeDefined();

    const emailInput = getByTestId("email-field");
    expect(emailInput).toBeDefined();

    const passwordInput = getByTestId("password-field");
    expect(passwordInput).toBeDefined();

    const signUpButton = getByTestId("sign-up-button");
    expect(signUpButton).toBeDefined();
  });

  it("should correctly fill the email and password fields", () => {
    const { getByTestId } = render(<SignUp />);
    const emailInput = getByTestId("email-field") as HTMLInputElement;
    const passwordInput = getByTestId("password-field") as HTMLInputElement;

    fireEvent.change(emailInput, { target: { value: "user@quivr.app" } });
    fireEvent.change(passwordInput, { target: { value: "password123" } });
    expect(emailInput.value).toBe("user@quivr.app");
    expect(passwordInput.value).toBe("password123");
  });

  it("should call handleSignUp on submit", () => {
    vi.mock("../hooks/useSignUp", async () => {
      const functions = await vi.importActual<
        typeof import("../hooks/useSignUp")
      >("../hooks/useSignUp");

      return {
        useSignUp: () => ({
          ...functions.useSignUp(),
          handleSignUp: () => mockHandleSignUp(),
        }),
      };
    });

    const { getByTestId } = render(<SignUp />);
    const submitForm = getByTestId("sign-up-form") as HTMLFormElement;

    fireEvent.submit(submitForm);
    expect(mockHandleSignUp).toHaveBeenCalled();
  });
});
```
"/Users/aswin/Documents/quivr/frontend/app/(auth)/signup/hooks/useSignUp.ts" ```import { useState } from "react";

import { useSupabase } from "@/lib/context/SupabaseProvider";
import { useToast } from "@/lib/hooks/useToast";
import { useEventTracking } from "@/services/analytics/useEventTracking";

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export const useSignUp = () => {
  const { supabase } = useSupabase();
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [isPending, setIsPending] = useState(false);
  const { track } = useEventTracking();

  const { publish } = useToast();
  const handleSignUp = async () => {
    void track("SIGNUP");
    setIsPending(true);
    const { error } = await supabase.auth.signUp({
      email: email,
      password: password,
    });

    if (error) {
      console.error("Error signing up:", error.message);
      publish({
        variant: "danger",
        text: `Error signing up: ${error.message}`,
      });
    } else {
      publish({
        variant: "success",
        text: "Confirmation Email sent, please check your email",
      });
    }
    setIsPending(false);
  };

  return {
    handleSignUp,
    setEmail,
    password,
    setPassword,
    isPending,
    email,
  };
};
```. these are the nextjs javascript frontend code for login and signup. how can i integrate stripe payment as shown in the example code? go through the nextjs javascript code extensively. give me only complete correct modified nextjs javascript code