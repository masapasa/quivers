```import os
import requests
import streamlit as st
import openai
from IPython.display import display
from PIL import Image
import dotenv
dotenv.load_dotenv(verbose=True)
image_dir_name = "images"
image_dir = os.path.join(os.curdir, image_dir_name)
response = False
prompt_tokens = 0
completion_tokes = 0
total_tokens_used = 0
cost_of_response = 0
API_KEY = os.getenv("OPENAI_API_KEY")
openai.api_key = API_KEY


def make_request(question_input: str):
    response = openai.ChatCompletion.create(
        model="gpt-3.5-turbo",
        messages=[
            {"role": "system", "content": f"{question_input}"},
        ]
    )
    return response


st.header("Streamlit + OpenAI ChatGPT API")

st.markdown("""---""")

question_input = st.text_input("Enter question", value = "step by step guide in detail on how to use underdog api to airdrop batch of NFTs to a list of addresses")
rerun_button = st.button("Rerun")

st.markdown("""---""")

if question_input:
    response = make_request(question_input)
else:
    pass

if rerun_button:
    response = make_request(question_input)
else:
    pass

if response:
    st.write("Response:")
    st.write(response["choices"][0]["message"]["content"])

    prompt_tokens = response["usage"]["prompt_tokens"]
    completion_tokes = response["usage"]["completion_tokens"]
    total_tokens_used = response["usage"]["total_tokens"]

    cost_of_response = total_tokens_used * 0.000002
    if st.button("Summarize"):
        prompt = response
        def make_summary(prompt: str):
            response_summary = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=[
                    {"role": "system", "content": f"Summarize this {prompt} in one sentence."},
                ]
            )
            return response_summary
        answer = make_summary(prompt)["choices"][0]["message"]["content"]
        st.write(answer)```. this is the python code where a user is able to generate content based on the user prompt. the content created is summarised with openai api. the created summary is used as a prompt to generate image. "pages/admin.vue" ```<script setup lang='ts'>
import { useToast } from 'primevue/usetoast';
import { CreateNFTBodyParams } from '../server/utils/underdog';
import openaiApi from "../server/api/generate/openaiApi"


  const { data } = await useAsyncData<{ subscribers: string[] }>('subscribers',
    () => $fetch('/api/subscribers', {
      method: 'GET',
    })
  );
  
  const toast = useToast();
  
  const nft = useState('nft', () => {
    return {
      name: '',
      description: '',
      symbol: '',
      image: '',
    }
  });
  
  const imageName = useState<string>('imageName', () => '');
  
  const customImageBase64Uploader = async (event: any) => {
    const file = event.files[0];
    imageName.value = file.name;
    const reader = new FileReader();
    let blob = await fetch(file.objectURL).then((r) => r.blob());
  
    reader.readAsDataURL(blob);
  
    reader.onloadend = function () {
      nft.value.image = reader.result?.toString() ?? '';
    };
  };
  
  const isLoading = useState('isLoading', () => false);
  
  const onSubmit = async () => {
    toast.add({
      severity: 'info', summary: 'Loading', detail: 'Distributing NFTs...', life: 3000,
    });
    isLoading.value = true;
    const res = await $fetch('/api/nfts/batch', {
      method: 'POST',
      body: <CreateNFTBodyParams>{
        image: nft.value.image,
        name: nft.value.name,
        description: nft.value.description,
        symbol: nft.value.symbol,
      }
    })
    if (res.statusCode == 200) {
      toast.add({ severity: 'success', summary: 'Success', detail: 'Successfully distributed âœ…', life: 3000 });
      isLoading.value = false;
    }
  }
  
  const prompt = useState<string>('prompt', () => '');
  
  const generateImage = async () => {
    try {
      const response = await $fetch("/api/generate",{
        method:"POST",
        body: {
          prompt: prompt.value,
        }
      });
      if (response && response.statusCode === 200) {
        nft.value.image = response.image;
        console.log(nft.value.image);
      }
  
    } catch (error: any) {
      console.log(error);
    }
  }
  </script>
<template>
    <div class="h-screen w-screen flex flex-row relative">
      <div v-if="isLoading" class="w-screen h-screen flex items-center justify-center absolute z-30 backdrop-blur-lg">
        <ProgressSpinner strokeWidth="4" />
      </div>
      <div class="w-1/2 flex flex-col justify-center items-center p-10 bg-white/[0.02] border-r border-r-white/5">
        <div class="flex flex-col w-full">
          <FileUpload v-if="!nft.image" mode="advanced" :fileLimit="1" :showUploadButton="false" name="meme"
            accept="image/*" :maxFileSize="10000000" customUpload @uploader="customImageBase64Uploader" auto />
  
          <div v-else
            class="text-lg mb-4 bg-gray-900 shadow-lg shadow-black/10 border-white/5 p-4 rounded-md text-white/50">
            {{ imageName }}
          </div>
  
          <div class="flex flex-col py-8 space-y-7">
            <span class="p-float-label">
              <InputText class="w-full" v-model="prompt" type="text" />
              <label for="value">Prompt</label>
              <img class="w-full" :src="nft.image" />
            </span>
  
            <Button outlined class="w-[80%]" type="submit" label="Generate Image" @click="generateImage" />
  
            <span class="p-float-label">
              <InputText class="w-full" v-model="nft.name" type="text" />
              <label for="value">Name</label>
            </span>
  
            <span class="p-float-label">
              <InputText class="w-full" v-model="nft.symbol" type="text" />
              <label for="value">Symbol</label>
            </span>
  
            <span class="p-float-label">
              <Textarea class="w-full" v-model="nft.description" type="text" />
              <label for = "value">Description</label>
            </span>
          </div>
        </div>
      </div>
  
      <div :class="[ 'w-1/2 flex flex-col justify-center items-center p-10 space-y-5 transition-all duration-500',
        nft.image === '' || nft.description === '' || nft.symbol === '' || nft.name === '' ? 'opacity-20 blur-lg' : ''
      ]">
        <div class="w-[80%] p-5 rounded-lg bg-white/5">
          <p class="text-lg">{{ data?.subscribers.length }} Subscribers</p>
          <p class = "text-white/80" v-for= "sub in data?.subscribers" :key= "sub">
            {{ sub }}
          </p>
        </div>
        <Button outlined class ="w-[80%]" type= "submit" label= "Send out MemeLetter" @click= "onSubmit" />
      </div>
    </div>
  </template>```"server/api/generate/index.post.ts" ```import { Configuration, OpenAIApi } from 'openai'
const config = useRuntimeConfig();

const configuration = new Configuration({
  apiKey: config.openaiApiKey
});
const openaiApi = new OpenAIApi(configuration);

export default defineEventHandler(async (event) => {

  const {prompt} = (await readBody(event)) as { prompt: string };

  try {
    const response = await openaiApi.createImage({
      prompt: prompt,
      n: 1,
      size: '1024x1024',
      response_format: 'url'
    })
    return {
      statusCode: 200,
      image: response.data.data[0].url || ''
    }
  } catch (error: any) {
    console.log(error);
    return {
      statusCode: 500,
      message: `${error}`,
    };
  }
});```. in this vuejs javascript app, user is able to generate an image and mint that image as nft. i want to give creators the ability to create content with their prompt as demonstrated in python code. that content will be summarized using openai api and the summaries used as a image generation prompt. implement this feature in veujs javascript. modify "pages/admin.vue" and "server/api" as needed. give me only complete correct modified vuejs javascript code based on the code provided

step by step guide in detail on how to use underdog protocol to airdrop NFTs to subscribers

3d white rabbit, character, smiling, open mouth, big teeth, cgi, holding chocolate, beside a blank sign, forest scenary, hyperrealistic, 8k