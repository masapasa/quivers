"/Users/aswin/Documents/quivr/frontend/lib/api/create-customer-and-subscription.ts" ```// pages/api/create-customer-and-subscription.ts

import type { NextApiRequest, NextApiResponse } from "next";
import axios from "axios";

type CreateCustomerAndSubscriptionRequest = {
  email: string;
  subscriptionType: string;
};

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  const { email, subscriptionType } = req.body as CreateCustomerAndSubscriptionRequest;

  // Send a request to the FastAPI backend to create a new customer and subscription in Stripe
  try {
    const response = await axios.post(
      `/create-customer-and-subscription`,
      {
        email,
        subscriptionType,
      }
    );
    res.status(200).json(response.data);
  } catch (error) {
    console.error("Error creating customer and subscription:", error);
    res.status(500).json({ error: error.message });
  }
}
```
"/Users/aswin/Documents/quivr/frontend/lib/api/index.ts" ``````
"/Users/aswin/Documents/quivr/frontend/lib/api/chat/useChatApi.ts" ```import { useAxios } from "@/lib/hooks";

import {
  addQuestion,
  AddQuestionParams,
  ChatUpdatableProperties,
  createChat,
  deleteChat,
  getChats,
  getHistory,
  updateChat,
} from "./chat";

// TODO: split './chat.ts' into multiple files, per function for example
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export const useChatApi = () => {
  const { axiosInstance } = useAxios();

  return {
    createChat: async (chatName: string) => createChat(chatName, axiosInstance),
    getChats: async () => getChats(axiosInstance),
    deleteChat: async (chatId: string) => deleteChat(chatId, axiosInstance),
    addQuestion: async (props: AddQuestionParams) =>
      addQuestion(props, axiosInstance),
    getHistory: async (chatId: string) => getHistory(chatId, axiosInstance),
    updateChat: async (chatId: string, props: ChatUpdatableProperties) =>
      updateChat(chatId, props, axiosInstance),
  };
};
```
"/Users/aswin/Documents/quivr/frontend/lib/api/chat/chat.ts" ```import { AxiosInstance } from "axios";

import {
  ChatEntity,
  ChatHistory,
  ChatQuestion,
} from "@/app/chat/[chatId]/types";

export const createChat = async (
  name: string,
  axiosInstance: AxiosInstance
): Promise<ChatEntity> => {
  const createdChat = (
    await axiosInstance.post<ChatEntity>("/chat", { name: name })
  ).data;

  return createdChat;
};

export const getChats = async (
  axiosInstance: AxiosInstance
): Promise<ChatEntity[]> => {
  const response = await axiosInstance.get<{
    chats: ChatEntity[];
  }>(`/chat`);

  return response.data.chats;
};

export const deleteChat = async (
  chatId: string,
  axiosInstance: AxiosInstance
): Promise<void> => {
  await axiosInstance.delete(`/chat/${chatId}`);
};

export type AddQuestionParams = {
  chatId: string;
  chatQuestion: ChatQuestion;
  brainId: string;
};

export const addQuestion = async (
  { chatId, chatQuestion, brainId }: AddQuestionParams,
  axiosInstance: AxiosInstance
): Promise<ChatHistory> => {
  const response = await axiosInstance.post<ChatHistory>(
    `/chat/${chatId}/question?brain_id=${brainId}`,
    chatQuestion
  );

  return response.data;
};

export const getHistory = async (
  chatId: string,
  axiosInstance: AxiosInstance
): Promise<ChatHistory[]> =>
  (await axiosInstance.get<ChatHistory[]>(`/chat/${chatId}/history`)).data;

export type ChatUpdatableProperties = {
  chat_name?: string;
};
export const updateChat = async (
  chatId: string,
  chat: ChatUpdatableProperties,
  axiosInstance: AxiosInstance
): Promise<ChatEntity> => {
  return (await axiosInstance.put<ChatEntity>(`/chat/${chatId}/metadata`, chat))
    .data;
};
```
"/Users/aswin/Documents/quivr/frontend/lib/api/chat/__tests__/useChatApi.test.ts" ```/* eslint-disable max-lines */
import { renderHook } from "@testing-library/react";
import { afterEach, describe, expect, it, vi } from "vitest";

import { ChatQuestion } from "@/app/chat/[chatId]/types";

import { useChatApi } from "../useChatApi";

const axiosPostMock = vi.fn(() => ({}));
const axiosGetMock = vi.fn(() => ({}));
const axiosPutMock = vi.fn(() => ({}));
const axiosDeleteMock = vi.fn(() => ({}));

vi.mock("@/lib/hooks", () => ({
  useAxios: () => ({
    axiosInstance: {
      post: axiosPostMock,
      get: axiosGetMock,
      put: axiosPutMock,
      delete: axiosDeleteMock,
    },
  }),
}));

describe("useChatApi", () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it("should call createChat with the correct parameters", async () => {
    const chatName = "Test Chat";
    axiosPostMock.mockReturnValue({ data: {} });
    const {
      result: {
        current: { createChat },
      },
    } = renderHook(() => useChatApi());
    await createChat(chatName);

    expect(axiosPostMock).toHaveBeenCalledTimes(1);
    expect(axiosPostMock).toHaveBeenCalledWith("/chat", {
      name: chatName,
    });
  });

  it("should call getChats with the correct parameters", async () => {
    axiosGetMock.mockReturnValue({ data: {} });
    const {
      result: {
        current: { getChats },
      },
    } = renderHook(() => useChatApi());

    await getChats();

    expect(axiosGetMock).toHaveBeenCalledTimes(1);
    expect(axiosGetMock).toHaveBeenCalledWith("/chat");
  });

  it("should call deleteChat with the correct parameters", async () => {
    const chatId = "test-chat-id";
    axiosDeleteMock.mockReturnValue({});
    const {
      result: {
        current: { deleteChat },
      },
    } = renderHook(() => useChatApi());

    await deleteChat(chatId);

    expect(axiosDeleteMock).toHaveBeenCalledTimes(1);
    expect(axiosDeleteMock).toHaveBeenCalledWith(`/chat/${chatId}`);
  });

  it("should call addQuestion with the correct parameters", async () => {
    const chatId = "test-chat-id";

    const chatQuestion: ChatQuestion = {
      question: "test-question",
      max_tokens: 10,
      model: "test-model",
      temperature: 0.5,
    };

    const brainId = "test-brain-id";

    const {
      result: {
        current: { addQuestion },
      },
    } = renderHook(() => useChatApi());

    await addQuestion({ chatId, chatQuestion, brainId });

    expect(axiosPostMock).toHaveBeenCalledTimes(1);
    expect(axiosPostMock).toHaveBeenCalledWith(
      `/chat/${chatId}/question?brain_id=${brainId}`,
      chatQuestion
    );
  });

  it("should call getHistory with the correct parameters", async () => {
    const chatId = "test-chat-id";
    axiosGetMock.mockReturnValue({ data: {} });
    const {
      result: {
        current: { getHistory },
      },
    } = renderHook(() => useChatApi());

    await getHistory(chatId);

    expect(axiosGetMock).toHaveBeenCalledTimes(1);
    expect(axiosGetMock).toHaveBeenCalledWith(`/chat/${chatId}/history`);
  });

  it("should call updateChat with the correct parameters", async () => {
    const chatId = "test-chat-id";
    const chatName = "test-chat-name";
    axiosPutMock.mockReturnValue({ data: {} });
    const {
      result: {
        current: { updateChat },
      },
    } = renderHook(() => useChatApi());

    await updateChat(chatId, { chat_name: chatName });

    expect(axiosPutMock).toHaveBeenCalledTimes(1);
    expect(axiosPutMock).toHaveBeenCalledWith(`/chat/${chatId}/metadata`, {
      chat_name: chatName,
    });
  });
});
```
"/Users/aswin/Documents/quivr/frontend/lib/api/chat/__tests__/useChatApi.http.test.ts" ```import { renderHook } from "@testing-library/react";
import { describe, expect, it } from "vitest";

import { getNock } from "../../tests/getNock";
import { useChatApi } from "../useChatApi";

getNock().options("/chat").reply(200);

describe("useChatApi", () => {
  it("should make http request while creating chat", async () => {
    const chatName = "Test Chat";

    const scope = getNock().post("/chat").reply(200, { chat_name: chatName });

    const {
      result: {
        current: { createChat },
      },
    } = renderHook(() => useChatApi());

    const createdChat = await createChat(chatName);

    //Check that the endpoint was called
    expect(scope.isDone()).toBe(true);

    expect(createdChat).toMatchObject({ chat_name: chatName });
  });
});
```
"/Users/aswin/Documents/quivr/frontend/lib/api/auth/useAuthApi.ts" ```import { useAxios } from "@/lib/hooks";

import { createApiKey } from "./auth";

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export const useAuthApi = () => {
  const { axiosInstance } = useAxios();

  return {
    createApiKey: async () => createApiKey(axiosInstance),
  };
};
```
"/Users/aswin/Documents/quivr/frontend/lib/api/auth/auth.ts" ```import { AxiosInstance } from "axios";

export const createApiKey = async (
  axiosInstance: AxiosInstance
): Promise<string> => {
  const response = await axiosInstance.post<{ api_key: string }>("/api-key");

  return response.data.api_key;
};```
"/Users/aswin/Documents/quivr/frontend/lib/api/auth/__tests__/useAuthApi.test.ts" ```import { renderHook } from "@testing-library/react";
import { describe, expect, it, vi } from "vitest";

import { useAuthApi } from "../useAuthApi";

const axiosPostMock = vi.fn(() => ({
  data: {
    api_key: "",
  },
}));

vi.mock("@/lib/hooks", () => ({
  useAxios: () => ({
    axiosInstance: {
      post: axiosPostMock,
    },
  }),
}));

describe("useAuthApi", () => {
  it("should call createApiKey with the correct parameters", async () => {
    const {
      result: {
        current: { createApiKey },
      },
    } = renderHook(() => useAuthApi());
    await createApiKey();
    expect(axiosPostMock).toHaveBeenCalledTimes(1);
    expect(axiosPostMock).toHaveBeenCalledWith("/api-key");
  });
});
```
"/Users/aswin/Documents/quivr/frontend/lib/api/tests/getNock.ts" ```import nock from "nock";
import { vi } from "vitest";

import { DEFAULT_BACKEND_URL } from "@/lib/config/CONSTANTS";

vi.mock("@/lib/context/SupabaseProvider", () => ({
  useSupabase: () => ({}),
}));

vi.mock("@/lib/context/BrainConfigProvider", () => ({
  useBrainConfig: () => ({
    config: {},
  }),
}));

export const getNock = (url?: string): nock.Scope => {
  return nock(
    url ?? `${process.env.NEXT_PUBLIC_BACKEND_URL ?? DEFAULT_BACKEND_URL}`
  ).defaultReplyHeaders({
    "access-control-allow-origin": "*",
    "access-control-allow-credentials": "true",
    "access-control-allow-headers": "Authorization",
  });
};
```
"/Users/aswin/Documents/quivr/frontend/lib/api/subscription/useSubscriptionApi.ts" ```import { UUID } from "crypto";

import { useAxios } from "@/lib/hooks";

import {
  acceptInvitation,
  declineInvitation,
  getInvitation,
} from "./subscription";

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export const useSubscriptionApi = () => {
  const { axiosInstance } = useAxios();

  return {
    acceptInvitation: async (brainId: UUID) =>
      acceptInvitation(brainId, axiosInstance),
    declineInvitation: async (brainId: UUID) =>
      declineInvitation(brainId, axiosInstance),
    getInvitation: async (brainId: UUID) =>
      getInvitation(brainId, axiosInstance),
  };
};
```
"/Users/aswin/Documents/quivr/frontend/lib/api/subscription/subscription.ts" ```import { AxiosInstance } from "axios";
import { UUID } from "crypto";

import { BrainRoleType } from "@/lib/components/NavBar/components/NavItems/components/BrainsDropDown/components/BrainActions/types";

export const acceptInvitation = async (
  brainId: UUID,
  axiosInstance: AxiosInstance
): Promise<{ message: string }> => {
  const acceptedInvitation = (
    await axiosInstance.post<{ message: string }>(
      `/brains/${brainId}/subscription/accept`
    )
  ).data;

  return acceptedInvitation;
};

export const declineInvitation = async (
  brainId: UUID,
  axiosInstance: AxiosInstance
): Promise<{ message: string }> => {
  const deletedInvitation = (
    await axiosInstance.post<{ message: string }>(
      `/brains/${brainId}/subscription/decline`
    )
  ).data;

  return deletedInvitation;
};

export type InvitationBrain = {
  name: string;
  role: BrainRoleType;
};

//TODO: rename rights to role in Backend and use InvitationBrain instead of BackendInvitationBrain
type BackendInvitationBrain = Omit<InvitationBrain, "role"> & {
  rights: BrainRoleType;
};

export const getInvitation = async (
  brainId: UUID,
  axiosInstance: AxiosInstance
): Promise<InvitationBrain> => {
  const invitation = (
    await axiosInstance.get<BackendInvitationBrain>(
      `/brains/${brainId}/subscription`
    )
  ).data;

  return {
    name: invitation.name,
    role: invitation.rights,
  };
};
```
"/Users/aswin/Documents/quivr/frontend/lib/api/brain/useBrainApi.ts" ```import { useAxios } from "@/lib/hooks";

import {
  addBrainSubscriptions,
  createBrain,
  deleteBrain,
  getBrain,
  getBrainDocuments,
  getBrains,
  getBrainUsers,
  getDefaultBrain,
  setAsDefaultBrain,
  Subscription,
  updateBrain,
  updateBrainAccess,
} from "./brain";
import {
  CreateBrainInput,
  SubscriptionUpdatableProperties,
  UpdateBrainInput,
} from "./types";

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export const useBrainApi = () => {
  const { axiosInstance } = useAxios();

  return {
    getBrainDocuments: async (brainId: string) =>
      getBrainDocuments(brainId, axiosInstance),
    createBrain: async (brain: CreateBrainInput) =>
      createBrain(brain, axiosInstance),
    deleteBrain: async (id: string) => deleteBrain(id, axiosInstance),
    getDefaultBrain: async () => getDefaultBrain(axiosInstance),
    getBrains: async () => getBrains(axiosInstance),
    getBrain: async (id: string) => getBrain(id, axiosInstance),
    addBrainSubscriptions: async (
      brainId: string,
      subscriptions: Subscription[]
    ) => addBrainSubscriptions(brainId, subscriptions, axiosInstance),
    getBrainUsers: async (brainId: string) =>
      getBrainUsers(brainId, axiosInstance),
    updateBrainAccess: async (
      brainId: string,
      userEmail: string,
      subscription: SubscriptionUpdatableProperties
    ) => updateBrainAccess(brainId, userEmail, subscription, axiosInstance),
    setAsDefaultBrain: async (brainId: string) =>
      setAsDefaultBrain(brainId, axiosInstance),
    updateBrain: async (brainId: string, brain: UpdateBrainInput) =>
      updateBrain(brainId, brain, axiosInstance),
  };
};
```
"/Users/aswin/Documents/quivr/frontend/lib/api/brain/brain.ts" ```/* eslint-disable max-lines */
import { AxiosInstance } from "axios";

import { BrainRoleType } from "@/lib/components/NavBar/components/NavItems/components/BrainsDropDown/components/BrainActions/types";
import {
  BackendMinimalBrainForUser,
  Brain,
  MinimalBrainForUser,
} from "@/lib/context/BrainProvider/types";
import { Document } from "@/lib/types/Document";

import {
  CreateBrainInput,
  SubscriptionUpdatableProperties,
  UpdateBrainInput,
} from "./types";
import { mapBackendMinimalBrainToMinimalBrain } from "./utils/mapBackendMinimalBrainToMinimalBrain";
import {
  BackendSubscription,
  mapSubscriptionToBackendSubscription,
} from "./utils/mapSubscriptionToBackendSubscription";
import { mapSubscriptionUpdatablePropertiesToBackendSubscriptionUpdatableProperties } from "./utils/mapSubscriptionUpdatablePropertiesToBackendSubscriptionUpdatableProperties";

export const getBrainDocuments = async (
  brainId: string,
  axiosInstance: AxiosInstance
): Promise<Document[]> => {
  const response = await axiosInstance.get<{ documents: Document[] }>(
    `/explore/?brain_id=${brainId}`
  );

  return response.data.documents;
};

export const createBrain = async (
  brain: CreateBrainInput,
  axiosInstance: AxiosInstance
): Promise<MinimalBrainForUser> => {
  return mapBackendMinimalBrainToMinimalBrain(
    (await axiosInstance.post<BackendMinimalBrainForUser>(`/brains/`, brain))
      .data
  );
};

export const getBrain = async (
  brainId: string,
  axiosInstance: AxiosInstance
): Promise<Brain | undefined> => {
  const brain = (
    await axiosInstance.get<Brain | undefined>(`/brains/${brainId}/`)
  ).data;

  return brain;
};

export const deleteBrain = async (
  brainId: string,
  axiosInstance: AxiosInstance
): Promise<void> => {
  await axiosInstance.delete(`/brains/${brainId}/subscription`);
};

export const getDefaultBrain = async (
  axiosInstance: AxiosInstance
): Promise<MinimalBrainForUser | undefined> => {
  return mapBackendMinimalBrainToMinimalBrain(
    (await axiosInstance.get<BackendMinimalBrainForUser>(`/brains/default/`))
      .data
  );
};

export const getBrains = async (
  axiosInstance: AxiosInstance
): Promise<MinimalBrainForUser[]> => {
  const { brains } = (
    await axiosInstance.get<{ brains: BackendMinimalBrainForUser[] }>(
      `/brains/`
    )
  ).data;

  return brains.map(mapBackendMinimalBrainToMinimalBrain);
};

export type Subscription = { email: string; role: BrainRoleType };

export const addBrainSubscriptions = async (
  brainId: string,
  subscriptions: Subscription[],
  axiosInstance: AxiosInstance
): Promise<void> => {
  await axiosInstance.post(
    `/brains/${brainId}/subscription`,
    subscriptions.map(mapSubscriptionToBackendSubscription)
  );
};

export const getBrainUsers = async (
  brainId: string,
  axiosInstance: AxiosInstance
): Promise<Subscription[]> => {
  const brainsUsers = (
    await axiosInstance.get<BackendSubscription[]>(`/brains/${brainId}/users`)
  ).data;

  return brainsUsers.map((brainUser) => ({
    email: brainUser.email,
    role: brainUser.rights,
  }));
};

export const updateBrainAccess = async (
  brainId: string,
  userEmail: string,
  subscription: SubscriptionUpdatableProperties,
  axiosInstance: AxiosInstance
): Promise<void> => {
  await axiosInstance.put(`/brains/${brainId}/subscription`, {
    ...mapSubscriptionUpdatablePropertiesToBackendSubscriptionUpdatableProperties(
      subscription
    ),
    email: userEmail,
  });
};

export const setAsDefaultBrain = async (
  brainId: string,
  axiosInstance: AxiosInstance
): Promise<void> => {
  await axiosInstance.post(`/brains/${brainId}/default`);
};

export const updateBrain = async (
  brainId: string,
  brain: UpdateBrainInput,
  axiosInstance: AxiosInstance
): Promise<void> => {
  await axiosInstance.put(`/brains/${brainId}/`, brain);
};
```
"/Users/aswin/Documents/quivr/frontend/lib/api/brain/types.ts" ```import { BrainRoleType } from "@/lib/components/NavBar/components/NavItems/components/BrainsDropDown/components/BrainActions/types";

export type SubscriptionUpdatableProperties = {
  role: BrainRoleType | null;
};

export type CreateBrainInput = {
  name: string;
  description?: string;
  status?: string;
  model?: string;
  temperature?: number;
  max_tokens?: number;
  openai_api_key?: string;
};

export type UpdateBrainInput = Partial<CreateBrainInput>;
```
"/Users/aswin/Documents/quivr/frontend/lib/api/brain/utils/mapSubscriptionToBackendSubscription.ts" ```import { BrainRoleType } from "@/lib/components/NavBar/components/NavItems/components/BrainsDropDown/components/BrainActions/types";

import { Subscription } from "../brain";

export type BackendSubscription = { email: string; rights: BrainRoleType };

export const mapSubscriptionToBackendSubscription = (
  subscription: Subscription
): BackendSubscription => ({
  email: subscription.email,
  rights: subscription.role,
});```
"/Users/aswin/Documents/quivr/frontend/lib/api/brain/utils/mapBackendMinimalBrainToMinimalBrain.ts" ```import {
  BackendMinimalBrainForUser,
  MinimalBrainForUser,
} from "@/lib/context/BrainProvider/types";

export const mapBackendMinimalBrainToMinimalBrain = (
  backendMinimalBrain: BackendMinimalBrainForUser
): MinimalBrainForUser => ({
  id: backendMinimalBrain.id,
  name: backendMinimalBrain.name,
  role: backendMinimalBrain.rights,
});```
"/Users/aswin/Documents/quivr/frontend/lib/api/brain/utils/mapSubscriptionUpdatablePropertiesToBackendSubscriptionUpdatableProperties.ts" ```import { BrainRoleType } from "@/lib/components/NavBar/components/NavItems/components/BrainsDropDown/components/BrainActions/types";

import { SubscriptionUpdatableProperties } from "../types";

type BackendSubscriptionUpdatableProperties = {
  rights: BrainRoleType | null;
};
export const mapSubscriptionUpdatablePropertiesToBackendSubscriptionUpdatableProperties =
  (
    subscriptionUpdatableProperties: SubscriptionUpdatableProperties
  ): BackendSubscriptionUpdatableProperties => ({
    rights: subscriptionUpdatableProperties.role,
  });```
"/Users/aswin/Documents/quivr/frontend/lib/api/brain/__tests__/useBrainApi.test.ts" ```/* eslint-disable max-lines */
import { renderHook } from "@testing-library/react";
import { afterEach, describe, expect, it, vi } from "vitest";

import { Subscription } from "../brain";
import {
  CreateBrainInput,
  SubscriptionUpdatableProperties,
  UpdateBrainInput,
} from "../types";
import { useBrainApi } from "../useBrainApi";

const axiosGetMock = vi.fn(() => ({
  data: {
    documents: [],
  },
}));

const axiosPostMock = vi.fn(() => ({
  data: {
    id: "123",
    name: "Test Brain",
  },
}));

const axiosDeleteMock = vi.fn(() => ({}));
const axiosPutMock = vi.fn(() => ({}));

vi.mock("@/lib/hooks", () => ({
  useAxios: vi.fn(() => ({
    axiosInstance: {
      get: axiosGetMock,
      post: axiosPostMock,
      delete: axiosDeleteMock,
      put: axiosPutMock,
    },
  })),
}));

describe("useBrainApi", () => {
  afterEach(() => {
    vi.restoreAllMocks();
  });

  it("should call getBrainDocuments with the correct parameters", async () => {
    const {
      result: {
        current: { getBrainDocuments },
      },
    } = renderHook(() => useBrainApi());
    const brainId = "123";
    await getBrainDocuments(brainId);

    expect(axiosGetMock).toHaveBeenCalledTimes(1);
    expect(axiosGetMock).toHaveBeenCalledWith(`/explore/?brain_id=${brainId}`);
  });

  it("should call createBrain with the correct parameters", async () => {
    const {
      result: {
        current: { createBrain },
      },
    } = renderHook(() => useBrainApi());

    const brain: CreateBrainInput = {
      name: "Test Brain",
      description: "This is a description",
      status: "public",
      model: "gpt-3.5-turbo-0613",
      temperature: 0.0,
      max_tokens: 256,
      openai_api_key: "123",
    };

    await createBrain(brain);

    expect(axiosPostMock).toHaveBeenCalledTimes(1);
    expect(axiosPostMock).toHaveBeenCalledWith("/brains/", brain);
  });

  it("should call deleteBrain with the correct parameters", async () => {
    const {
      result: {
        current: { deleteBrain },
      },
    } = renderHook(() => useBrainApi());
    const id = "123";
    await deleteBrain(id);

    expect(axiosDeleteMock).toHaveBeenCalledTimes(1);
    expect(axiosDeleteMock).toHaveBeenCalledWith(`/brains/${id}/subscription`);
  });

  it("should call getDefaultBrain with the correct parameters", async () => {
    const {
      result: {
        current: { getDefaultBrain },
      },
    } = renderHook(() => useBrainApi());
    await getDefaultBrain();

    expect(axiosGetMock).toHaveBeenCalledTimes(1);
    expect(axiosGetMock).toHaveBeenCalledWith("/brains/default/");
  });

  it("should call getBrains with the correct parameters", async () => {
    axiosGetMock.mockImplementationOnce(() => ({
      data: {
        //@ts-ignore we don't really need returned value here
        brains: [],
      },
    }));
    const {
      result: {
        current: { getBrains },
      },
    } = renderHook(() => useBrainApi());
    await getBrains();

    expect(axiosGetMock).toHaveBeenCalledTimes(1);
    expect(axiosGetMock).toHaveBeenCalledWith("/brains/");
  });

  it("should call getBrain with the correct parameters", async () => {
    const {
      result: {
        current: { getBrain },
      },
    } = renderHook(() => useBrainApi());
    const id = "123";
    await getBrain(id);

    expect(axiosGetMock).toHaveBeenCalledTimes(1);
    expect(axiosGetMock).toHaveBeenCalledWith(`/brains/${id}/`);
  });

  it("should call addBrainSubscription with the correct parameters", async () => {
    const {
      result: {
        current: { addBrainSubscriptions },
      },
    } = renderHook(() => useBrainApi());
    const id = "123";
    const subscriptions: Subscription[] = [
      {
        email: "user@quivr.app",
        role: "Viewer",
      },
    ];
    await addBrainSubscriptions(id, subscriptions);

    expect(axiosPostMock).toHaveBeenCalledTimes(1);
    expect(axiosPostMock).toHaveBeenCalledWith(`/brains/${id}/subscription`, [
      {
        email: "user@quivr.app",
        rights: "Viewer",
      },
    ]);
  });

  it("should call getBrainUsers with the correct parameters", async () => {
    axiosGetMock.mockImplementationOnce(() => ({
      //@ts-ignore we don't really need returned value here
      data: [],
    }));

    const {
      result: {
        current: { getBrainUsers },
      },
    } = renderHook(() => useBrainApi());
    const id = "123";
    await getBrainUsers(id);

    expect(axiosGetMock).toHaveBeenCalledTimes(1);
    expect(axiosGetMock).toHaveBeenCalledWith(`/brains/${id}/users`);
  });
  it("should call updateBrainAccess with the correct parameters", async () => {
    const {
      result: {
        current: { updateBrainAccess },
      },
    } = renderHook(() => useBrainApi());
    const brainId = "123";
    const email = "456";
    const subscription: SubscriptionUpdatableProperties = {
      role: "Viewer",
    };
    await updateBrainAccess(brainId, email, subscription);
    expect(axiosPutMock).toHaveBeenCalledTimes(1);
    expect(axiosPutMock).toHaveBeenCalledWith(
      `/brains/${brainId}/subscription`,
      { rights: "Viewer", email }
    );
  });

  it("should call setAsDefaultBrain with correct brainId", async () => {
    const {
      result: {
        current: { setAsDefaultBrain },
      },
    } = renderHook(() => useBrainApi());
    const brainId = "123";
    await setAsDefaultBrain(brainId);
    expect(axiosPostMock).toHaveBeenCalledTimes(1);
    expect(axiosPostMock).toHaveBeenCalledWith(`/brains/${brainId}/default`);
  });

  it("should call updateBrain with correct brainId and brain", async () => {
    const {
      result: {
        current: { updateBrain },
      },
    } = renderHook(() => useBrainApi());
    const brainId = "123";
    const brain: UpdateBrainInput = {
      name: "Test Brain",
      description: "This is a description",
      status: "public",
      model: "gpt-3.5-turbo-0613",
      temperature: 0.0,
      max_tokens: 256,
      openai_api_key: "123",
    };
    await updateBrain(brainId, brain);
    expect(axiosPutMock).toHaveBeenCalledTimes(1);
    expect(axiosPutMock).toHaveBeenCalledWith(`/brains/${brainId}/`, brain);
  });
});
```. this is the api route of my nextjs javascript frontend app which allows loggedin users create brain, share brain, upload files and chat with the files. how can i integrate stripe payment as shown in this example? "app/api/create-checkout-session/route.ts" ```import { cookies, headers } from 'next/headers';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { stripe } from '@/utils/stripe';
import { createOrRetrieveCustomer } from '@/utils/supabase-admin';
import { getURL } from '@/utils/helpers';
import { Database } from '@/types_db';

export async function POST(req: Request) {
  if (req.method === 'POST') {
    const { price, quantity = 1, metadata = {} } = await req.json();

    try {
      const supabase = createRouteHandlerClient<Database>({cookies});
      const {
        data: { user }
      } = await supabase.auth.getUser();
      const customer = await createOrRetrieveCustomer({
        uuid: user?.id || '',
        email: user?.email || ''
      });
      let session;
      if (price.type === 'recurring') {
        session = await stripe.checkout.sessions.create({
          payment_method_types: ['card'],
          billing_address_collection: 'required',
          customer,
          customer_update: {
            address: 'auto'
          },
          line_items: [
            {
              price: price.id,
              quantity
            }
          ],
          mode: 'subscription',
          allow_promotion_codes: true,
          subscription_data: {
            trial_from_plan: true,
            metadata
          },
          success_url: `${getURL()}/account`,
          cancel_url: `${getURL()}/`
        });
      } else if (price.type === 'one_time') {
        session = await stripe.checkout.sessions.create({
          payment_method_types: ['card'],
          billing_address_collection: 'required',
          customer,
          customer_update: {
            address: 'auto'
          },
          line_items: [
            {
              price: price.id,
              quantity
            }
          ],
          mode: 'payment',
          allow_promotion_codes: true,
          success_url: `${getURL()}/account`,
          cancel_url: `${getURL()}/`
        });
      }

      if (session) {
        return new Response(JSON.stringify({ sessionId: session.id }), {
          status: 200
        });
      } else {
        return new Response(
          JSON.stringify({
            error: { statusCode: 500, message: 'Session is not defined' }
          }),
          { status: 500 }
        );
      }
    } catch (err: any) {
      console.log(err);
      return new Response(JSON.stringify(err), { status: 500 });
    }
  } else {
    return new Response('Method Not Allowed', {
      headers: { Allow: 'POST' },
      status: 405
    });
  }
}```"components/Pricing.tsx" ```'use client';

import Button from '@/components/ui/Button';
import { Database } from '@/types_db';
import { postData } from '@/utils/helpers';
import { getStripe } from '@/utils/stripe-client';
import { Session, User } from '@supabase/supabase-js';
import cn from 'classnames';
import { useRouter } from 'next/navigation';
import { useState } from 'react';

type Subscription = Database['public']['Tables']['subscriptions']['Row'];
type Product = Database['public']['Tables']['products']['Row'];
type Price = Database['public']['Tables']['prices']['Row'];
interface ProductWithPrices extends Product {
  prices: Price[];
}
interface PriceWithProduct extends Price {
  products: Product | null;
}
interface SubscriptionWithProduct extends Subscription {
  prices: PriceWithProduct | null;
}

interface Props {
  session: Session | null;
  user: User | null | undefined;
  products: ProductWithPrices[];
  subscription: SubscriptionWithProduct | null;
}

type BillingInterval = 'lifetime' | 'year' | 'month';

export default function Pricing({
  session,
  user,
  products,
  subscription
}: Props) {
  const intervals = Array.from(
    new Set(
      products.flatMap((product) =>
        product?.prices?.map((price) => price?.interval)
      )
    )
  );
  const router = useRouter();
  const [billingInterval, setBillingInterval] =
    useState<BillingInterval>('month');
  const [priceIdLoading, setPriceIdLoading] = useState<string>();

  const handleCheckout = async (price: Price) => {
    setPriceIdLoading(price.id);
    if (!user) {
      return router.push('/signin');
    }
    if (subscription) {
      return router.push('/account');
    }
    try {
      const { sessionId } = await postData({
        url: '/api/create-checkout-session',
        data: { price }
      });

      const stripe = await getStripe();
      stripe?.redirectToCheckout({ sessionId });
    } catch (error) {
      return alert((error as Error)?.message);
    } finally {
      setPriceIdLoading(undefined);
    }
  };

  if (!products.length)
    return (
      <section className="bg-black">
        <div className="max-w-6xl px-4 py-8 mx-auto sm:py-24 sm:px-6 lg:px-8">
          <div className="sm:flex sm:flex-col sm:align-center"></div>
          <p className="text-4xl font-extrabold text-white sm:text-center sm:text-6xl">
            No subscription pricing plans found. Create them in your{' '}
            <a
              className="text-pink-500 underline"
              href="https://dashboard.stripe.com/products"
              rel="noopener noreferrer"
              target="_blank"
            >
              Stripe Dashboard
            </a>
            .
          </p>
        </div>
        <LogoCloud />
      </section>
    );

  if (products.length === 1)
    return (
      <section className="bg-black">
        <div className="max-w-6xl px-4 py-8 mx-auto sm:py-24 sm:px-6 lg:px-8">
          <div className="sm:flex sm:flex-col sm:align-center">
            <h1 className="text-4xl font-extrabold text-white sm:text-center sm:text-6xl">
              Pricing Plans
            </h1>
            <p className="max-w-2xl m-auto mt-5 text-xl text-zinc-200 sm:text-center sm:text-2xl">
              Start building for free, then add a site plan to go live. Account
              plans unlock additional features.
            </p>
            <div className="relative flex self-center mt-12 border rounded-lg bg-zinc-900 border-zinc-800">
              <div className="border border-pink-500 border-opacity-50 divide-y rounded-lg shadow-sm bg-zinc-900 divide-zinc-600">
                <div className="p-6 py-2 m-1 text-2xl font-medium text-white rounded-md shadow-sm border-zinc-800 whitespace-nowrap focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-opacity-50 focus:z-10 sm:w-auto sm:px-8">
                  {products[0].name}
                </div>
              </div>
            </div>
            <div className="mt-6 space-y-4 sm:mt-12 sm:space-y-0 sm:grid sm:grid-cols-2 sm:gap-6 lg:max-w-4xl lg:mx-auto xl:max-w-none xl:mx-0 xl:grid-cols-3">
              {products[0].prices?.map((price) => {
                const priceString =
                  price.unit_amount &&
                  new Intl.NumberFormat('en-US', {
                    style: 'currency',
                    currency: price.currency!,
                    minimumFractionDigits: 0
                  }).format(price.unit_amount / 100);

                return (
                  <div
                    key={price.interval}
                    className="divide-y rounded-lg shadow-sm divide-zinc-600 bg-zinc-900"
                  >
                    <div className="p-6">
                      <p>
                        <span className="text-5xl font-extrabold white">
                          {priceString}
                        </span>
                        <span className="text-base font-medium text-zinc-100">
                          /{price.interval}
                        </span>
                      </p>
                      <p className="mt-4 text-zinc-300">{price.description}</p>
                      <Button
                        variant="slim"
                        type="button"
                        disabled={false}
                        loading={priceIdLoading === price.id}
                        onClick={() => handleCheckout(price)}
                        className="block w-full py-2 mt-12 text-sm font-semibold text-center text-white rounded-md hover:bg-zinc-900 "
                      >
                        {products[0].name ===
                        subscription?.prices?.products?.name
                          ? 'Manage'
                          : 'Subscribe'}
                      </Button>
                    </div>
                  </div>
                );
              })}
            </div>
          </div>
          <LogoCloud />
        </div>
      </section>
    );

  return (
    <section className="bg-black">
      <div className="max-w-6xl px-4 py-8 mx-auto sm:py-24 sm:px-6 lg:px-8">
        <div className="sm:flex sm:flex-col sm:align-center">
          <h1 className="text-4xl font-extrabold text-white sm:text-center sm:text-6xl">
            Pricing Plans
          </h1>
          <p className="max-w-2xl m-auto mt-5 text-xl text-zinc-200 sm:text-center sm:text-2xl">
            Start building for free, then add a site plan to go live. Account
            plans unlock additional features.
          </p>
          <div className="relative self-center mt-6 bg-zinc-900 rounded-lg p-0.5 flex sm:mt-8 border border-zinc-800">
            {intervals.includes('month') && (
              <button
                onClick={() => setBillingInterval('month')}
                type="button"
                className={`${
                  billingInterval === 'month'
                    ? 'relative w-1/2 bg-zinc-700 border-zinc-800 shadow-sm text-white'
                    : 'ml-0.5 relative w-1/2 border border-transparent text-zinc-400'
                } rounded-md m-1 py-2 text-sm font-medium whitespace-nowrap focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-opacity-50 focus:z-10 sm:w-auto sm:px-8`}
              >
                Monthly billing
              </button>
            )}
            {intervals.includes('year') && (
              <button
                onClick={() => setBillingInterval('year')}
                type="button"
                className={`${
                  billingInterval === 'year'
                    ? 'relative w-1/2 bg-zinc-700 border-zinc-800 shadow-sm text-white'
                    : 'ml-0.5 relative w-1/2 border border-transparent text-zinc-400'
                } rounded-md m-1 py-2 text-sm font-medium whitespace-nowrap focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-opacity-50 focus:z-10 sm:w-auto sm:px-8`}
              >
                Yearly billing
              </button>
            )}
          </div>
        </div>
        <div className="mt-12 space-y-4 sm:mt-16 sm:space-y-0 sm:grid sm:grid-cols-2 sm:gap-6 lg:max-w-4xl lg:mx-auto xl:max-w-none xl:mx-0 xl:grid-cols-3">
          {products.map((product) => {
            const price = product?.prices?.find(
              (price) => price.interval === billingInterval
            );
            if (!price) return null;
            const priceString = new Intl.NumberFormat('en-US', {
              style: 'currency',
              currency: price.currency!,
              minimumFractionDigits: 0
            }).format((price?.unit_amount || 0) / 100);
            return (
              <div
                key={product.id}
                className={cn(
                  'rounded-lg shadow-sm divide-y divide-zinc-600 bg-zinc-900',
                  {
                    'border border-pink-500': subscription
                      ? product.name === subscription?.prices?.products?.name
                      : product.name === 'Freelancer'
                  }
                )}
              >
                <div className="p-6">
                  <h2 className="text-2xl font-semibold leading-6 text-white">
                    {product.name}
                  </h2>
                  <p className="mt-4 text-zinc-300">{product.description}</p>
                  <p className="mt-8">
                    <span className="text-5xl font-extrabold white">
                      {priceString}
                    </span>
                    <span className="text-base font-medium text-zinc-100">
                      /{billingInterval}
                    </span>
                  </p>
                  <Button
                    variant="slim"
                    type="button"
                    disabled={!session}
                    loading={priceIdLoading === price.id}
                    onClick={() => handleCheckout(price)}
                    className="block w-full py-2 mt-8 text-sm font-semibold text-center text-white rounded-md hover:bg-zinc-900"
                  >
                    {subscription ? 'Manage' : 'Subscribe'}
                  </Button>
                </div>
              </div>
            );
          })}
        </div>
        <LogoCloud />
      </div>
    </section>
  );
}

function LogoCloud() {
  return (
    <div>
      <p className="mt-24 text-xs uppercase text-zinc-400 text-center font-bold tracking-[0.3em]">
        Brought to you by
      </p>
      <div className="flex flex-col items-center my-12 space-y-4 sm:mt-8 sm:space-y-0 md:mx-auto md:max-w-2xl sm:grid sm:gap-6 sm:grid-cols-5">
        <div className="flex items-center justify-start">
          <a href="https://nextjs.org" aria-label="Next.js Link">
            <img
              src="/nextjs.svg"
              alt="Next.js Logo"
              className="h-12 text-white"
            />
          </a>
        </div>
        <div className="flex items-center justify-start">
          <a href="https://vercel.com" aria-label="Vercel.com Link">
            <img
              src="/vercel.svg"
              alt="Vercel.com Logo"
              className="h-6 text-white"
            />
          </a>
        </div>
        <div className="flex items-center justify-start">
          <a href="https://stripe.com" aria-label="stripe.com Link">
            <img
              src="/stripe.svg"
              alt="stripe.com Logo"
              className="h-12 text-white"
            />
          </a>
        </div>
        <div className="flex items-center justify-start">
          <a href="https://supabase.io" aria-label="supabase.io Link">
            <img
              src="/supabase.svg"
              alt="supabase.io Logo"
              className="h-10 text-white"
            />
          </a>
        </div>
        <div className="flex items-center justify-start">
          <a href="https://github.com" aria-label="github.com Link">
            <img
              src="/github.svg"
              alt="github.com Logo"
              className="h-8 text-white"
            />
          </a>
        </div>
      </div>
    </div>
  );
}```"utils/supabase-admin.ts" ```import { toDateTime } from './helpers';
import { stripe } from './stripe';
import { createClient } from '@supabase/supabase-js';
import Stripe from 'stripe';
import type { Database } from 'types_db';

type Product = Database['public']['Tables']['products']['Row'];
type Price = Database['public']['Tables']['prices']['Row'];
const supabaseAdmin = createClient<Database>(
  process.env.NEXT_PUBLIC_SUPABASE_URL || '',
  process.env.SUPABASE_SERVICE_ROLE_KEY || ''
);

const upsertProductRecord = async (product: Stripe.Product) => {
  const productData: Product = {
    id: product.id,
    active: product.active,
    name: product.name,
    description: product.description ?? null,
    image: product.images?.[0] ?? null,
    metadata: product.metadata
  };

  const { error } = await supabaseAdmin.from('products').upsert([productData]);
  if (error) throw error;
  console.log(`Product inserted/updated: ${product.id}`);
};

const upsertPriceRecord = async (price: Stripe.Price) => {
  const priceData: Price = {
    id: price.id,
    product_id: typeof price.product === 'string' ? price.product : '',
    active: price.active,
    currency: price.currency,
    description: price.nickname ?? null,
    type: price.type,
    unit_amount: price.unit_amount ?? null,
    interval: price.recurring?.interval ?? null,
    interval_count: price.recurring?.interval_count ?? null,
    trial_period_days: price.recurring?.trial_period_days ?? null,
    metadata: price.metadata
  };

  const { error } = await supabaseAdmin.from('prices').upsert([priceData]);
  if (error) throw error;
  console.log(`Price inserted/updated: ${price.id}`);
};

const createOrRetrieveCustomer = async ({
  email,
  uuid
}: {
  email: string;
  uuid: string;
}) => {
  const { data, error } = await supabaseAdmin
    .from('customers')
    .select('stripe_customer_id')
    .eq('id', uuid)
    .single();
  if (error || !data?.stripe_customer_id) {
    const customerData: { metadata: { supabaseUUID: string }; email?: string } =
      {
        metadata: {
          supabaseUUID: uuid
        }
      };
    if (email) customerData.email = email;
    const customer = await stripe.customers.create(customerData);
    const { error: supabaseError } = await supabaseAdmin
      .from('customers')
      .insert([{ id: uuid, stripe_customer_id: customer.id }]);
    if (supabaseError) throw supabaseError;
    console.log(`New customer created and inserted for ${uuid}.`);
    return customer.id;
  }
  return data.stripe_customer_id;
};
const copyBillingDetailsToCustomer = async (
  uuid: string,
  payment_method: Stripe.PaymentMethod
) => {
  const customer = payment_method.customer as string;
  const { name, phone, address } = payment_method.billing_details;
  if (!name || !phone || !address) return;
  await stripe.customers.update(customer, { name, phone, address });
  const { error } = await supabaseAdmin
    .from('users')
    .update({
      billing_address: { ...address },
      payment_method: { ...payment_method[payment_method.type] }
    })
    .eq('id', uuid);
  if (error) throw error;
};

const manageSubscriptionStatusChange = async (
  subscriptionId: string,
  customerId: string,
  createAction = false
) => {
  const { data: customerData, error: noCustomerError } = await supabaseAdmin
    .from('customers')
    .select('id')
    .eq('stripe_customer_id', customerId)
    .single();
  if (noCustomerError) throw noCustomerError;

  const { id: uuid } = customerData!;

  const subscription = await stripe.subscriptions.retrieve(subscriptionId, {
    expand: ['default_payment_method']
  });
  const subscriptionData: Database['public']['Tables']['subscriptions']['Insert'] =
    {
      id: subscription.id,
      user_id: uuid,
      metadata: subscription.metadata,
      status: subscription.status,
      price_id: subscription.items.data[0].price.id,
      quantity: subscription.quantity,
      cancel_at_period_end: subscription.cancel_at_period_end,
      cancel_at: subscription.cancel_at
        ? toDateTime(subscription.cancel_at).toISOString()
        : null,
      canceled_at: subscription.canceled_at
        ? toDateTime(subscription.canceled_at).toISOString()
        : null,
      current_period_start: toDateTime(
        subscription.current_period_start
      ).toISOString(),
      current_period_end: toDateTime(
        subscription.current_period_end
      ).toISOString(),
      created: toDateTime(subscription.created).toISOString(),
      ended_at: subscription.ended_at
        ? toDateTime(subscription.ended_at).toISOString()
        : null,
      trial_start: subscription.trial_start
        ? toDateTime(subscription.trial_start).toISOString()
        : null,
      trial_end: subscription.trial_end
        ? toDateTime(subscription.trial_end).toISOString()
        : null
    };

  const { error } = await supabaseAdmin
    .from('subscriptions')
    .upsert([subscriptionData]);
  if (error) throw error;
  console.log(
    `Inserted/updated subscription [${subscription.id}] for user [${uuid}]`
  );
  if (createAction && subscription.default_payment_method && uuid)
    await copyBillingDetailsToCustomer(
      uuid,
      subscription.default_payment_method as Stripe.PaymentMethod
    );
};

export {
  upsertProductRecord,
  upsertPriceRecord,
  createOrRetrieveCustomer,
  manageSubscriptionStatusChange
};```. give me only complete correct modified nextjs javascript frontend code