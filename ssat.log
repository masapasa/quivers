"/DeveloperWeek-Hack/packages/truffle/contracts/CamoToken.sol" ```// SPDX-License-Identifier: MIT
// Author:- @sauravrao637
pragma solidity ^0.8.18;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract CamoToken is ERC20, Ownable {
    uint256 public constant MAX_SUPPLY = 10_000_000_000 * (10**18);

    constructor() ERC20("Camo Token", "CAMO") {
        uint256 toMint = MAX_SUPPLY;
        _mint(msg.sender, toMint);
    }
}
```
"/DeveloperWeek-Hack/packages/truffle/contracts/CamoStaking.sol" ```// SPDX-License-Identifier: GPL-3.0-only
// Author:- @sauravrao637
pragma solidity ^0.8.18;

import "./CamoNFT.sol";
import "./CamoToken.sol";

contract CamoStaking is Ownable {
    struct Staker {
        uint256 userJoinedTS;
        uint256 reward;
    }

    uint256 public leftSupply;

    mapping(address => Staker) stakers;
    address[] stakingAddress;

    uint256 public tier1Rate;
    uint256 public tier2Rate;
    uint256 public tier3Rate;
    uint256 public tier4Rate;
    uint256 public tier5Rate;

    CamoToken public camoTokenAddress;

    CamoNFT public camoNFTAddress;

    address private serverAddress;

    event StakedWallet(address indexed user);

    event WithdrawnRewards(address indexed user, uint256 amount);

    constructor(uint256 baseRewardRate) {
        tier1Rate = baseRewardRate;
        tier2Rate = tier1Rate * 2;
        tier3Rate = tier1Rate * 3;
        tier4Rate = tier1Rate * 5;
        tier5Rate = tier1Rate * 8;
    }

    modifier onlyStaker() {
        require(stakers[msg.sender].userJoinedTS > 0, "Not a staker");
        _;
    }

    modifier onlyAuthorized() {
        require(serverAddress == msg.sender, "Not Authorised");
        _;
    }

    function getMax(uint256 a, uint256 b) internal pure returns (uint256) {
        return a >= b ? a : b;
    }

    function setCamoNFTAddress(address _camoNFTAddress) public onlyOwner {
        require(address(camoNFTAddress) == address(0), "Already Set");
        camoNFTAddress = CamoNFT(_camoNFTAddress);
    }

    function setTokenAddressAndSendFunds(address _tokenAddress) public onlyOwner{
        camoTokenAddress = CamoToken(_tokenAddress);
        uint256 totalSupply = camoTokenAddress.MAX_SUPPLY();
        camoTokenAddress.transferFrom(msg.sender, address(this), totalSupply);
        leftSupply = totalSupply-1;
    }

    function setServerAddress(address _serverAddress) public onlyOwner{
        serverAddress = _serverAddress;
    }

    function getSupplyRatio() public view returns (uint256) {
        return (leftSupply * 10**18) / camoTokenAddress.MAX_SUPPLY();
    }

    function stakeWallet() public {
        require(stakers[msg.sender].userJoinedTS == 0, "Already Staked");
        stakers[msg.sender] = Staker(block.timestamp, 0);
        stakingAddress.push(msg.sender);
        emit StakedWallet(msg.sender);
    }

    function claimReward() public onlyStaker {
        uint256 reward = stakers[msg.sender].reward;
        camoTokenAddress.transfer(msg.sender, reward);
        stakers[msg.sender].reward -= reward;
    }

    function getNftById(uint256 tokenId)
        internal
        view
        returns (
            uint256,
            address,
            CamoNFT.RarityLevel,
            uint256,
            uint256
        )
    {
        return camoNFTAddress.nfts(tokenId);
    }

    function calculateIncentive(address _user) internal view returns (uint256) {
        uint256 incentiveAmount = 0;
        uint256[] memory tokens = camoNFTAddress.getOwnedTokens(_user);
        for (uint256 i = 0; i < tokens.length; i++) {
            (
                ,
                ,
                CamoNFT.RarityLevel rarity,
                uint256 entryTimestamp,
                uint256 stakeClaimedTimeStamp
            ) = getNftById(tokens[i]);
            uint256 lastStaked = getMax(entryTimestamp, stakeClaimedTimeStamp);
            uint256 holdingTime = ((block.timestamp - lastStaked));
            uint256 rate = getRate(rarity);
            incentiveAmount += (rate * holdingTime * 10**18)/ 60_000;
        }
        return incentiveAmount;
    }

    // Function to distribute incentives to all stakers based on the duration they hold the NFTs
    function distributeIncentives() public onlyAuthorized {
        uint256 total = 0;
        uint256 currSupplyRatio = getSupplyRatio();
        for (uint256 i = 0; i < stakingAddress.length; i++) {
            address _user = stakingAddress[i];
            uint256 reward = (currSupplyRatio * calculateIncentive(_user))/ 10**18;
            camoNFTAddress.updateTimestamp(_user);
            stakers[_user].reward += reward;
            total += reward;
        }
        leftSupply -= total;
    }

    function getRate(CamoNFT.RarityLevel rarity) public view returns (uint256) {
        if (rarity == CamoNFT.RarityLevel.Common) {
            return tier1Rate;
        } else if (rarity == CamoNFT.RarityLevel.Uncommon) {
            return tier2Rate;
        } else if (rarity == CamoNFT.RarityLevel.Rare) {
            return tier3Rate;
        } else if (rarity == CamoNFT.RarityLevel.Epic) {
            return tier4Rate;
        } else if (rarity == CamoNFT.RarityLevel.Legendary) {
            return tier5Rate;
        }
        revert("Invalid rarity level");
    }
    function getStaker(address _user) public view onlyOwner returns(Staker memory staker){
        staker = stakers[_user];
    }

    function amIStaker() public view onlyStaker returns(bool){
        return true;
    }

    function rewardAccumulated() public view onlyStaker returns(uint256){
        return stakers[msg.sender].reward;
    }
}
```
"/DeveloperWeek-Hack/packages/truffle/contracts/CamoNFT.sol" ```// SPDX-License-Identifier: GPL-3.0-only
// Author:- @sauravrao637
pragma solidity ^0.8.18;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract CamoNFT is ERC721, Ownable {
    enum RarityLevel {Common, Uncommon, Rare, Epic, Legendary}
    uint256 counter = 0;
    struct NFT {
        uint256 tokenId;
        address owner;
        RarityLevel rarity;
        uint256 entryTimestamp;
        uint256 stakeClaimedTimeStamp;
    }

    uint256 constant public BASE_PRICE = 100_000_000_000_000_000 wei;
    uint256 constant public COMMON_PRICE = BASE_PRICE *1;
    uint256 constant public UNCOMMON_PRICE = BASE_PRICE *2;
    uint256 constant public RARE_PRICE = BASE_PRICE *3;
    uint256 constant public EPIC_PRICE = BASE_PRICE *5;
    uint256 constant public LEGENDARY_PRICE = BASE_PRICE *8;

    uint256 constant public COMMON_CAP = 22500;
    uint256 constant public UNCOMMON_CAP = 2500;
    uint256 constant public RARE_CAP = 900;
    uint256 constant public EPIC_CAP = 100;
    uint256 constant public LEGENDARY_CAP = 25;

    mapping(uint256 => NFT) public nfts;
    mapping(address => uint256[]) private _ownedTokens;

    address public authorizedContract;

    uint256 public commonCount;
    uint256 public uncommonCount;
    uint256 public rareCount;
    uint256 public epicCount;
    uint256 public legendaryCount;

    constructor(address _authorizedContract) ERC721("CamoNFT", "CNFT") {
        authorizedContract = _authorizedContract;
    }

    modifier onlyAuthorizedContract() {
        require(authorizedContract == msg.sender, "Unauthorized contract");
        _;
    }

    function mintNFT(RarityLevel rarity) external payable {
        require(rarity >= RarityLevel.Common && rarity <= RarityLevel.Legendary, "Invalid rarity level");

        uint256 price = getPrice(rarity);
        require(msg.value >= price, "Insufficient payment");

        require(getCount(rarity) < getCap(rarity), "Rarity level sold out");
        uint256 tokenId = counter;
        counter++;
        _safeMint(msg.sender, tokenId);
        _ownedTokens[msg.sender].push(tokenId);
        nfts[tokenId] = NFT(tokenId, msg.sender, rarity, block.timestamp, block.timestamp);
        updateCount(rarity);

        if (msg.value > price) {
            payable(msg.sender).transfer(msg.value - price);
        }
    }

    function transferFrom(address from, address to, uint256 tokenId) public override {
        super.transferFrom(from, to, tokenId);
        require(_isApprovedOrOwner(_msgSender(), tokenId), "Transfer not authorized");
        require(from != to, "What are you doing?");

        // Remove token ID from sender's list
        uint256[] storage fromTokenList = _ownedTokens[from];
        for (uint256 i = 0; i < fromTokenList.length; i++) {
            if (fromTokenList[i] == tokenId) {
                fromTokenList[i] = fromTokenList[fromTokenList.length - 1];
                fromTokenList.pop();
                break;
            }
        }

        // Add token ID to receiver's list
        _ownedTokens[to].push(tokenId);

        // Perform the transfer
        _transfer(from, to, tokenId);

        nfts[tokenId].entryTimestamp = block.timestamp;
        nfts[tokenId].owner = to;
    }

    function getPrice(RarityLevel rarity) public pure returns (uint256) {
        if (rarity == RarityLevel.Common) {
            return COMMON_PRICE;
        } else if (rarity == RarityLevel.Uncommon) {
            return UNCOMMON_PRICE;
        } else if (rarity == RarityLevel.Rare) {
            return RARE_PRICE;
        } else if (rarity == RarityLevel.Epic) {
            return EPIC_PRICE;
        } else if (rarity == RarityLevel.Legendary) {
            return LEGENDARY_PRICE;
        }
        revert("Invalid rarity level");
    }


    function getCap(RarityLevel rarity) public pure returns (uint256) {
        if (rarity == RarityLevel.Common) {
            return COMMON_CAP;
        } else if (rarity == RarityLevel.Uncommon) {
            return UNCOMMON_CAP;
        } else if (rarity == RarityLevel.Rare) {
            return RARE_CAP;
        } else if (rarity == RarityLevel.Epic) {
            return EPIC_CAP;
        } else if (rarity == RarityLevel.Legendary) {
            return LEGENDARY_CAP;
        }
        revert("Invalid rarity level");
    }

    function getCount(RarityLevel rarity) public view returns (uint256) {
        if (rarity == RarityLevel.Common) {
            return commonCount;
        } else if (rarity == RarityLevel.Uncommon) {
            return uncommonCount;
        } else if (rarity == RarityLevel.Rare) {
            return rareCount;
        } else if (rarity == RarityLevel.Epic) {
            return epicCount;
        } else if (rarity == RarityLevel.Legendary) {
            return legendaryCount;
        }
        revert("Invalid rarity level");
    }

    function updateCount(RarityLevel rarity) internal {
        if (rarity == RarityLevel.Common) {
            commonCount++;
        } else if (rarity == RarityLevel.Uncommon) {
            uncommonCount++;
        } else if (rarity == RarityLevel.Rare) {
            rareCount++;
        } else if (rarity == RarityLevel.Epic) {
            epicCount++;
        } else if (rarity == RarityLevel.Legendary) {
            legendaryCount++;
        }
    }

    function getOwnedTokens(address owner) external view onlyAuthorizedContract returns (uint256[] memory) {
        return _ownedTokens[owner];
    }

    function updateTimestamp(address user) external onlyAuthorizedContract {
        uint256[] storage tokenList = _ownedTokens[user];
        for(uint i=0;i< tokenList.length; i++){
            uint256 tokenId = tokenList[i];
            nfts[tokenId].entryTimestamp = block.timestamp;
        }
    }

    function withdrawFunds() public payable onlyOwner{
        payable(msg.sender).transfer(address(this).balance);
    }

    function checkBalance() public view onlyOwner returns(uint256){
        return address(this).balance;
    }
}

```. can you think of ways to further refining our reward calculation system? we recognize the need to offer a more versatile and customizable solution to cater to different staking requirements. how can we integrate regeneratice finance? maybe the ability to mint NFTs as you offset carbon and higher rewards for higher carbon offset? give me only complete correct modified solidity code